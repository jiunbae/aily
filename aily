#!/bin/bash
# aily -- CLI for managing AI agent notification relay.
# Single self-contained tool: setup wizard, diagnostics, dashboard API,
# thread management, and platform configuration.
#
# Usage:
#   aily init              Interactive setup wizard
#   aily status            Show configuration and connectivity status
#   aily sessions          List active sessions from dashboard
#   aily sync [name]       Trigger message sync for a session
#   aily logs [name]       Fetch recent messages for a session
#   aily attach [name]     Attach to a tmux session
#   aily export <name>     Export session messages
#   aily config ...        Show/edit configuration
#   aily doctor            Diagnose common issues
#   aily start [name]      Create thread for tmux session
#   aily stop [name]       Archive thread for tmux session
#   aily auto [on|off]     Toggle auto thread sync
#   aily uninstall         Remove aily hooks and configuration
#   aily help              Show this help

set -euo pipefail

# ---------------------------------------------------------------------------
# Paths
# ---------------------------------------------------------------------------
_self="$0"
# Resolve symlinks to find the actual repo directory
if [[ -L "$_self" ]]; then
  _self="$(readlink "$_self")"
  # Handle relative symlinks
  [[ "$_self" != /* ]] && _self="$(cd "$(dirname "$0")" && cd "$(dirname "$_self")" && pwd)/$(basename "$_self")"
fi
SCRIPT_DIR="$(cd "$(dirname "$_self")" && pwd)"
_AILY_CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/aily"
if [[ -n "${AILY_ENV:-}" ]]; then
  ENV_FILE="$AILY_ENV"
else
  ENV_FILE="$_AILY_CONFIG_DIR/env"
fi
HOOKS_DIR="$HOME/.claude/hooks"
AILY_VERSION="2026.2.18"
AILY_JSON=false

# ---------------------------------------------------------------------------
# Colors & formatting
# ---------------------------------------------------------------------------
if [[ -t 1 ]]; then
  C_RESET=$'\033[0m'
  C_BOLD=$'\033[1m'
  C_DIM=$'\033[2m'
  C_RED=$'\033[31m'
  C_GREEN=$'\033[32m'
  C_YELLOW=$'\033[33m'
  C_BLUE=$'\033[34m'
  C_CYAN=$'\033[36m'
  C_MAGENTA=$'\033[35m'
else
  C_RESET="" C_BOLD="" C_DIM="" C_RED="" C_GREEN=""
  C_YELLOW="" C_BLUE="" C_CYAN="" C_MAGENTA=""
fi

ok()   { printf "  ${C_GREEN}‚úì${C_RESET} %s\n" "$*"; }
warn() { printf "  ${C_YELLOW}‚ö†Ô∏è${C_RESET}  %s\n" "$*"; }
err()  { printf "  ${C_RED}‚úó${C_RESET} %s\n" "$*" >&2; }
info() { printf "  ${C_CYAN}¬∑${C_RESET} %s\n" "$*"; }
hdr()  { printf "\n${C_BOLD}=== %s ===${C_RESET}\n" "$*"; }

json_output() {
  # If --json flag is set, output JSON instead of formatted text.
  if [[ "$AILY_JSON" == true ]]; then
    printf '%s\n' "$1"
    return 0
  fi
  return 1
}

# ---------------------------------------------------------------------------
# Interactive UI toolkit (pure bash + ANSI)
# ---------------------------------------------------------------------------

# Cleanup state
_UI_CURSOR_HIDDEN=false
_UI_SPINNER_PID=""

_ui_cleanup() {
  if [[ "$_UI_CURSOR_HIDDEN" == true ]]; then
    printf '\033[?25h' >&2
    _UI_CURSOR_HIDDEN=false
  fi
  if [[ -n "$_UI_SPINNER_PID" ]] && kill -0 "$_UI_SPINNER_PID" 2>/dev/null; then
    kill "$_UI_SPINNER_PID" 2>/dev/null
    wait "$_UI_SPINNER_PID" 2>/dev/null || true
    _UI_SPINNER_PID=""
  fi
}
trap '_ui_cleanup' EXIT
trap '_ui_cleanup; exit 130' INT
trap '_ui_cleanup; exit 143' TERM

ui_spin() {
  # Usage: ui_spin "label" command [args...]
  # Animated braille spinner while command runs. Returns command exit code.
  local _label="$1"; shift

  # Non-TTY fallback
  if [[ ! -t 2 ]]; then
    printf "  %s... " "$_label" >&2
    local _rc=0
    "$@" >/dev/null 2>&1 || _rc=$?
    if [[ $_rc -eq 0 ]]; then
      printf "OK\n" >&2
    else
      printf "FAILED\n" >&2
    fi
    return $_rc
  fi

  local _frames="‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚†á‚†è"
  local _nframes=10

  printf '\033[?25l' >&2
  _UI_CURSOR_HIDDEN=true

  "$@" >/dev/null 2>&1 &
  _UI_SPINNER_PID=$!

  local _i=0
  while kill -0 "$_UI_SPINNER_PID" 2>/dev/null; do
    local _f="${_frames:$(( _i % _nframes )):1}"
    printf '\r\033[2K  %b%s%b %s' "$C_CYAN" "$_f" "$C_RESET" "$_label" >&2
    sleep 0.08
    _i=$(( _i + 1 ))
  done

  set +e
  wait "$_UI_SPINNER_PID" 2>/dev/null
  local _rc=$?
  set -e
  _UI_SPINNER_PID=""

  if [[ $_rc -eq 0 ]]; then
    printf '\r\033[2K  %b‚úì%b %s\n' "$C_GREEN" "$C_RESET" "$_label" >&2
  else
    printf '\r\033[2K  %b‚úó%b %s\n' "$C_RED" "$C_RESET" "$_label" >&2
  fi

  printf '\033[?25h' >&2
  _UI_CURSOR_HIDDEN=false
  return $_rc
}

ui_select() {
  # Usage: ui_select <var_name> <label> <opt1> <opt2> ... [-- <desc1> <desc2> ...]
  # Arrow-key / j,k navigation. Sets var to 0-based index.
  local _var="$1" _label="$2"; shift 2

  local _opts=() _descs=() _in_opts=true
  while [[ $# -gt 0 ]]; do
    if [[ "$1" == "--" ]]; then
      _in_opts=false; shift; continue
    fi
    if [[ "$_in_opts" == true ]]; then
      _opts[${#_opts[@]}]="$1"
    else
      _descs[${#_descs[@]}]="$1"
    fi
    shift
  done

  local _n=${#_opts[@]}
  local _sel=0

  # Non-TTY fallback: numbered list
  if [[ ! -t 0 ]]; then
    printf "  %s\n" "$_label" >&2
    local _i
    for (( _i=0; _i<_n; _i++ )); do
      local _d=""
      [[ ${#_descs[@]} -gt $_i ]] && _d="  (${_descs[$_i]})"
      printf "    %d) %s%s\n" "$((_i+1))" "${_opts[$_i]}" "$_d" >&2
    done
    local _choice
    read -rp "  Choice [1]: " _choice 2>&1
    _choice="${_choice:-1}"
    eval "$_var=$(( _choice - 1 ))"
    return
  fi

  printf '\033[?25l' >&2
  _UI_CURSOR_HIDDEN=true

  # Print label with hint
  printf "  %b%s%b  %b(‚Üë‚Üì/jk to move, enter to select)%b\n" \
    "$C_BOLD" "$_label" "$C_RESET" "$C_DIM" "$C_RESET" >&2

  # Render options
  _ui_sel_draw() {
    local _i
    for (( _i=0; _i<_n; _i++ )); do
      printf '\033[2K' >&2
      local _d=""
      [[ ${#_descs[@]} -gt $_i ]] && _d="  ${C_DIM}${_descs[$_i]}${C_RESET}"
      if [[ $_i -eq $_sel ]]; then
        printf "    %b>%b %b%s%b%b\n" "$C_CYAN" "$C_RESET" "$C_BOLD" "${_opts[$_i]}" "$C_RESET" "$_d" >&2
      else
        printf "      %s%b\n" "${_opts[$_i]}" "$_d" >&2
      fi
    done
  }
  _ui_sel_draw

  while true; do
    local _key=""
    IFS= read -rsn1 _key

    if [[ "$_key" == $'\033' ]]; then
      local _seq=""
      read -rsn2 -t 1 _seq || true
      case "$_seq" in
        '[A') [[ $_sel -gt 0 ]] && _sel=$(( _sel - 1 )) ;;
        '[B') [[ $_sel -lt $(( _n - 1 )) ]] && _sel=$(( _sel + 1 )) ;;
      esac
    elif [[ "$_key" == "k" ]]; then
      [[ $_sel -gt 0 ]] && _sel=$(( _sel - 1 ))
    elif [[ "$_key" == "j" ]]; then
      [[ $_sel -lt $(( _n - 1 )) ]] && _sel=$(( _sel + 1 ))
    elif [[ "$_key" == "" ]]; then
      break
    fi

    # Move up _n lines and redraw
    printf "\033[${_n}A" >&2
    _ui_sel_draw
  done

  printf '\033[?25h' >&2
  _UI_CURSOR_HIDDEN=false

  eval "$_var=$_sel"
}

ui_confirm() {
  # Usage: ui_confirm "label" [default: y|n]
  # Returns 0 for yes, 1 for no.
  local _label="$1" _default="${2:-y}"

  if [[ ! -t 0 ]]; then
    [[ "$_default" == "y" ]] && return 0 || return 1
  fi

  local _hint
  if [[ "$_default" == "y" ]]; then
    _hint="${C_BOLD}Y${C_RESET}${C_DIM}/n${C_RESET}"
  else
    _hint="${C_DIM}y/${C_RESET}${C_BOLD}N${C_RESET}"
  fi
  local _answer
  printf "  %s [%b]: " "$_label" "$_hint" >&2
  read -rn1 _answer </dev/tty
  echo "" >&2
  _answer="${_answer:-$_default}"
  case "$_answer" in
    [Yy]) return 0 ;;
    *)    return 1 ;;
  esac
}

# ---------------------------------------------------------------------------
# Dependency check
# ---------------------------------------------------------------------------
require_cmd() {
  local cmd="$1" hint="${2:-}"
  if ! command -v "$cmd" >/dev/null 2>&1; then
    err "$cmd not found${hint:+ ($hint)}"
    return 1
  fi
  return 0
}

require_deps() {
  local missing=0
  require_cmd curl   "install via your package manager" || missing=1
  require_cmd jq     "install via: brew install jq / apt install jq" || missing=1
  if [[ $missing -ne 0 ]]; then
    echo "" >&2
    err "Missing required dependencies. Install them and retry."
    exit 1
  fi
}

# ---------------------------------------------------------------------------
# Config helpers
# ---------------------------------------------------------------------------
env_get() {
  local key="$1" default="${2:-}"
  if [[ -f "$ENV_FILE" ]]; then
    local val
    val=$(grep -E "^${key}=" "$ENV_FILE" 2>/dev/null | tail -1 | cut -d= -f2- | tr -d '"' | tr -d "'")
    echo "${val:-$default}"
  else
    echo "$default"
  fi
}

env_set() {
  local key="$1" value="$2"
  if [[ ! -f "$ENV_FILE" ]]; then
    mkdir -p "$(dirname "$ENV_FILE")"
    touch "$ENV_FILE"
    chmod 600 "$ENV_FILE"
  fi
  if grep -qE "^${key}=" "$ENV_FILE" 2>/dev/null; then
    # Use python3 for safe in-place edit (matches install.sh style)
    python3 -c "
import re, sys
path = sys.argv[1]
key, val = sys.argv[2], sys.argv[3]
with open(path) as f:
    text = f.read()
text = re.sub(rf'^{key}=.*$', f'{key}=\"{val}\"', text, flags=re.MULTILINE)
with open(path, 'w') as f:
    f.write(text)
" "$ENV_FILE" "$key" "$value"
  else
    # Append with a blank separator if the file doesn't end with a newline
    if [[ -s "$ENV_FILE" ]] && [[ "$(tail -c1 "$ENV_FILE")" != "" ]]; then
      echo "" >> "$ENV_FILE"
    fi
    echo "${key}=\"${value}\"" >> "$ENV_FILE"
  fi
}

load_env() {
  if [[ -f "$ENV_FILE" ]]; then
    # shellcheck source=/dev/null
    source "$ENV_FILE"
  fi
}

redact() {
  local val="$1" show="${2:-4}"
  if [[ ${#val} -le $((show + 4)) ]]; then
    echo "****"
  else
    echo "${val:0:$show}...${val: -4}"
  fi
}

_generate_token() {
  if command -v openssl >/dev/null 2>&1; then
    openssl rand -hex 32
  elif command -v python3 >/dev/null 2>&1; then
    python3 -c "import secrets; print(secrets.token_hex(32))"
  else
    LC_ALL=C tr -dc 'a-f0-9' < /dev/urandom | head -c 64
    echo ""
  fi
}

# ---------------------------------------------------------------------------
# Dashboard API helpers
# ---------------------------------------------------------------------------
dashboard_url() {
  env_get "AILY_DASHBOARD_URL" "http://localhost:8080"
}

dashboard_token() {
  env_get "AILY_AUTH_TOKEN" ""
}

api_call() {
  local method="$1" path="$2"
  shift 2
  local url
  url="$(dashboard_url)${path}"
  local token
  token="$(dashboard_token)"

  local auth_header=""
  if [[ -n "$token" ]]; then
    auth_header="Authorization: Bearer ${token}"
  fi

  if [[ "$method" == "GET" ]]; then
    if [[ -n "$auth_header" ]]; then
      curl -sf -H "$auth_header" -H "Content-Type: application/json" "$url" "$@" 2>/dev/null
    else
      curl -sf -H "Content-Type: application/json" "$url" "$@" 2>/dev/null
    fi
  else
    if [[ -n "$auth_header" ]]; then
      curl -sf -X "$method" -H "$auth_header" -H "Content-Type: application/json" "$url" "$@" 2>/dev/null
    else
      curl -sf -X "$method" -H "Content-Type: application/json" "$url" "$@" 2>/dev/null
    fi
  fi
}

# ---------------------------------------------------------------------------
# tmux helpers
# ---------------------------------------------------------------------------
detect_tmux_session() {
  local TMUX_BIN="/opt/homebrew/bin/tmux"
  if [[ ! -x "$TMUX_BIN" ]]; then
    TMUX_BIN="tmux"
  fi

  if [[ -n "${TMUX_PANE:-}" ]]; then
    "$TMUX_BIN" display-message -t "${TMUX_PANE}" -p '#{session_name}' 2>/dev/null || true
  elif [[ -n "${TMUX:-}" ]]; then
    "$TMUX_BIN" display-message -p '#S' 2>/dev/null || true
  fi
}

# ---------------------------------------------------------------------------
# Platform loaders (sourced from hooks dir)
# ---------------------------------------------------------------------------
load_discord_env() {
  if [[ ! -f "$ENV_FILE" ]]; then return 1; fi
  # shellcheck source=/dev/null
  source "$ENV_FILE"
  if [[ -z "${DISCORD_BOT_TOKEN:-}" || -z "${DISCORD_CHANNEL_ID:-}" ]]; then return 1; fi
  local lib="${HOOKS_DIR}/discord-lib.sh"
  if [[ ! -f "$lib" ]]; then return 1; fi
  # shellcheck source=/dev/null
  source "$lib"
  return 0
}

load_slack_env() {
  if [[ ! -f "$ENV_FILE" ]]; then return 1; fi
  # shellcheck source=/dev/null
  source "$ENV_FILE"
  if [[ -z "${SLACK_BOT_TOKEN:-}" || -z "${SLACK_CHANNEL_ID:-}" ]]; then return 1; fi
  local lib="${HOOKS_DIR}/slack-lib.sh"
  if [[ ! -f "$lib" ]]; then return 1; fi
  # shellcheck source=/dev/null
  source "$lib"
  return 0
}

# ---------------------------------------------------------------------------
# Prompt helpers (for init wizard)
# ---------------------------------------------------------------------------
prompt_value() {
  local label="$1" default="${2:-}" secret="${3:-false}"
  local value prompt
  prompt="  ${label}"
  if [[ -n "$default" ]]; then
    if [[ "$secret" == "true" ]]; then
      prompt+=" ${C_DIM}[$(redact "$default")]${C_RESET}"
    else
      prompt+=" ${C_DIM}[${default}]${C_RESET}"
    fi
  fi
  prompt+=": "

  if [[ "$secret" == "true" ]]; then
    # Use -s for hidden input; show **** feedback so user knows paste worked
    read -rsp "$prompt" value
    if [[ -n "$value" ]]; then
      printf '****\n' >&2
    else
      echo "" >&2
    fi
  else
    read -rp "$prompt" value
  fi
  echo "${value:-$default}"
}

prompt_yn() {
  local label="$1" default="${2:-y}"
  local hint="Y/n"
  if [[ "$default" == "n" ]]; then
    hint="y/N"
  fi
  local answer
  read -rp "  ${label} (${hint}): " answer
  answer="${answer:-$default}"
  case "$answer" in
    [Yy]|[Yy][Ee][Ss]) return 0 ;;
    *)                 return 1 ;;
  esac
}

# ===================================================================
# COMMANDS
# ===================================================================

# -------------------------------------------------------------------
# aily init
# -------------------------------------------------------------------
cmd_init() {
  local non_interactive=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --non-interactive) non_interactive=true; shift ;;
      *) shift ;;
    esac
  done

  require_deps

  hdr "aily setup wizard"
  echo ""

  # -- 1. Platform setup (required) --
  local discord_token="" discord_channel=""
  local slack_token="" slack_app_token="" slack_channel=""

  if [[ "$non_interactive" == "true" ]]; then
    discord_token="${DISCORD_BOT_TOKEN:-$(env_get DISCORD_BOT_TOKEN "")}"
    discord_channel="${DISCORD_CHANNEL_ID:-$(env_get DISCORD_CHANNEL_ID "")}"
    slack_token="${SLACK_BOT_TOKEN:-$(env_get SLACK_BOT_TOKEN "")}"
    slack_app_token="${SLACK_APP_TOKEN:-$(env_get SLACK_APP_TOKEN "")}"
    slack_channel="${SLACK_CHANNEL_ID:-$(env_get SLACK_CHANNEL_ID "")}"
  else
    # Determine default based on existing config
    local _plat_default=0
    if [[ -n "$(env_get DISCORD_BOT_TOKEN "")" && -n "$(env_get SLACK_BOT_TOKEN "")" ]]; then
      _plat_default=2
    elif [[ -n "$(env_get SLACK_BOT_TOKEN "")" ]]; then
      _plat_default=1
    fi

    local platform_idx="$_plat_default"
    ui_select platform_idx "Notification platform" \
      "discord" "slack" "both" \
      -- "Discord bot" "Slack bot" "Discord + Slack"

    # Discord tokens
    if [[ "$platform_idx" == 0 || "$platform_idx" == 2 ]]; then
      discord_token=$(prompt_value "Discord bot token" "$(env_get DISCORD_BOT_TOKEN "")" true)
      discord_channel=$(prompt_value "Discord channel ID" "$(env_get DISCORD_CHANNEL_ID "")")

      if [[ -n "$discord_token" && -n "$discord_channel" ]]; then
        local discord_resp=""
        discord_resp=$(curl -sf -H "Authorization: Bot ${discord_token}" \
          "https://discord.com/api/v10/channels/${discord_channel}" 2>/dev/null || echo "")
        if [[ -n "$discord_resp" ]] && echo "$discord_resp" | jq -e '.id' >/dev/null 2>&1; then
          local chan_name
          chan_name=$(echo "$discord_resp" | jq -r '.name // "unknown"')
          ok "Discord: ${chan_name}"
        else
          warn "Could not validate Discord credentials"
        fi
      fi
      echo ""
    fi

    # Slack tokens
    if [[ "$platform_idx" == 1 || "$platform_idx" == 2 ]]; then
      slack_token=$(prompt_value "Slack bot token (xoxb-...)" "$(env_get SLACK_BOT_TOKEN "")" true)
      slack_app_token=$(prompt_value "Slack app token (xapp-...)" "$(env_get SLACK_APP_TOKEN "")" true)
      slack_channel=$(prompt_value "Slack channel ID" "$(env_get SLACK_CHANNEL_ID "")")

      if [[ -n "$slack_token" && -n "$slack_channel" ]]; then
        local slack_resp=""
        slack_resp=$(curl -sf -H "Authorization: Bearer ${slack_token}" \
          "https://slack.com/api/conversations.info?channel=${slack_channel}" 2>/dev/null || echo "")
        if [[ -n "$slack_resp" ]] && echo "$slack_resp" | jq -e '.ok == true' >/dev/null 2>&1; then
          local chan_name
          chan_name=$(echo "$slack_resp" | jq -r '.channel.name // "unknown"')
          ok "Slack: #${chan_name}"
        else
          warn "Could not validate Slack credentials"
        fi
      fi
      echo ""
    fi
  fi

  # -- 2. Quick-start defaults gate --
  local use_defaults=true
  local ssh_hosts="localhost"
  local thread_cleanup="archive"
  local new_session_agent="" claude_remote_control="false"
  local url="" token=""

  if [[ "$non_interactive" == "true" ]]; then
    ssh_hosts="${SSH_HOSTS:-$(env_get SSH_HOSTS "localhost")}"
    thread_cleanup="${THREAD_CLEANUP:-archive}"
    new_session_agent="${NEW_SESSION_AGENT:-$(env_get NEW_SESSION_AGENT "")}"
    claude_remote_control="${CLAUDE_REMOTE_CONTROL:-$(env_get CLAUDE_REMOTE_CONTROL "false")}"
    url="${AILY_DASHBOARD_URL:-$(env_get AILY_DASHBOARD_URL "")}"
    token="${AILY_AUTH_TOKEN:-$(env_get AILY_AUTH_TOKEN "")}"
    # Auto-generate token for localhost if not set
    if [[ -n "$url" && -z "$token" && ( "$url" == *"localhost"* || "$url" == *"127.0.0.1"* ) ]]; then
      token="$(_generate_token)"
    fi
  else
    info "Defaults: SSH=localhost, cleanup=archive, no agent, no dashboard"
    if ! ui_confirm "Use defaults?" "y"; then
      use_defaults=false
    fi
    echo ""
  fi

  # -- 3. SSH hosts (advanced) --
  if [[ "$use_defaults" == "false" ]]; then
    ssh_hosts=$(prompt_value "SSH hosts (comma-separated)" "$(env_get SSH_HOSTS "localhost")")

    if [[ -n "$ssh_hosts" && "$ssh_hosts" != "localhost" ]]; then
      IFS=',' read -ra host_list <<< "$ssh_hosts"
      for host in "${host_list[@]}"; do
        host=$(echo "$host" | tr -d ' ')
        ui_spin "Testing SSH to ${host}" ssh -o ConnectTimeout=3 -o BatchMode=yes "$host" "echo ok" || true
      done
    fi
    echo ""

    # -- 4. Thread cleanup (advanced) --
    local cleanup_idx=0
    ui_select cleanup_idx "Thread cleanup" \
      "archive" "delete" \
      -- "keeps history" "removes thread"
    case "$cleanup_idx" in
      1) thread_cleanup="delete" ;;
      *) thread_cleanup="archive" ;;
    esac
    ok "Thread cleanup: ${thread_cleanup}"
    echo ""

    # -- 5. Agent auto-launch (advanced) --
    local agent_idx=0
    ui_select agent_idx "Agent auto-launch on !new" \
      "none" "claude" "codex" "gemini" \
      -- "just create tmux session" "start Claude Code" "start Codex CLI" "start Gemini CLI"
    case "$agent_idx" in
      1) new_session_agent="claude" ;;
      2) new_session_agent="codex" ;;
      3) new_session_agent="gemini" ;;
      *) new_session_agent="" ;;
    esac

    if [[ "$new_session_agent" == "claude" ]]; then
      if ui_confirm "Enable remote-control mode for Claude?" "n"; then
        claude_remote_control="true"
      fi
    fi

    if [[ -n "$new_session_agent" ]]; then
      local rc_label=""
      [[ "$claude_remote_control" == "true" ]] && rc_label=" + remote-control"
      ok "Agent: ${new_session_agent}${rc_label}"
    else
      ok "Agent: none"
    fi
    echo ""

    # -- 6. Dashboard (optional) --
    if ui_confirm "Enable dashboard?" "n"; then
      url=$(prompt_value "Dashboard URL" "$(env_get AILY_DASHBOARD_URL "http://localhost:8080")")
      url="${url%/}"

      local _is_localhost=false
      [[ "$url" == *"localhost"* || "$url" == *"127.0.0.1"* ]] && _is_localhost=true

      # Determine auth token
      local existing_token
      existing_token="$(env_get AILY_AUTH_TOKEN "")"

      if [[ "$_is_localhost" == true ]]; then
        # Localhost: always auto-generate, never prompt
        token="${existing_token:-$(_generate_token)}"
        ok "Auth token: $(redact "$token")"

        if ui_spin "Testing dashboard" curl -sf --connect-timeout 3 "${url}/healthz"; then
          : # dashboard already running
        else
          if ui_confirm "Start local dashboard?" "y"; then
            _start_local_dashboard "$url" "$token"
            ui_spin "Checking dashboard" curl -sf --connect-timeout 5 "${url}/healthz" || \
              warn "Dashboard not responding ‚Äî will work on next start"
          fi
        fi
      else
        # Remote: prompt for token
        token=$(prompt_value "Auth token" "$existing_token" true)
        if ui_spin "Testing dashboard" curl -sf --connect-timeout 3 "${url}/healthz"; then
          if [[ -n "$token" ]]; then
            ui_spin "Validating token" curl -sf --connect-timeout 3 \
              -H "Authorization: Bearer ${token}" "${url}/api/stats" || \
              warn "Token validation failed"
          fi
        else
          warn "Dashboard not reachable ‚Äî continuing"
        fi
      fi
    fi
  fi
  echo ""

  # -- Write config --
  mkdir -p "$(dirname "$ENV_FILE")"

  local config_content=""
  config_content+="# aily configuration ‚Äî generated by aily init\n"
  config_content+="# $(date '+%Y-%m-%d %H:%M:%S')\n"
  config_content+="\n"
  config_content+="# --- Discord ---\n"
  if [[ -n "$discord_token" ]]; then
    config_content+="DISCORD_BOT_TOKEN=\"${discord_token}\"\n"
    config_content+="DISCORD_CHANNEL_ID=\"${discord_channel}\"\n"
  else
    config_content+="# DISCORD_BOT_TOKEN=\"\"\n"
    config_content+="# DISCORD_CHANNEL_ID=\"\"\n"
  fi
  config_content+="\n"
  config_content+="# --- Slack ---\n"
  if [[ -n "$slack_token" ]]; then
    config_content+="SLACK_BOT_TOKEN=\"${slack_token}\"\n"
    config_content+="SLACK_APP_TOKEN=\"${slack_app_token}\"\n"
    config_content+="SLACK_CHANNEL_ID=\"${slack_channel}\"\n"
  else
    config_content+="# SLACK_BOT_TOKEN=\"\"\n"
    config_content+="# SLACK_APP_TOKEN=\"\"\n"
    config_content+="# SLACK_CHANNEL_ID=\"\"\n"
  fi
  config_content+="\n"
  config_content+="# --- General ---\n"
  config_content+="SSH_HOSTS=\"${ssh_hosts}\"\n"
  config_content+="TMUX_THREAD_SYNC=\"true\"\n"
  config_content+="THREAD_CLEANUP=\"${thread_cleanup}\"\n"
  config_content+="\n"
  config_content+="# --- Agent Auto-Launch ---\n"
  if [[ -n "$new_session_agent" ]]; then
    config_content+="NEW_SESSION_AGENT=\"${new_session_agent}\"\n"
  else
    config_content+="# NEW_SESSION_AGENT=\"\"\n"
  fi
  if [[ "$claude_remote_control" == "true" ]]; then
    config_content+="CLAUDE_REMOTE_CONTROL=\"true\"\n"
  else
    config_content+="# CLAUDE_REMOTE_CONTROL=\"false\"\n"
  fi
  config_content+="\n"
  config_content+="# --- Dashboard (optional) ---\n"
  if [[ -n "$url" ]]; then
    config_content+="AILY_DASHBOARD_URL=\"${url}\"\n"
    [[ -n "$token" ]] && config_content+="AILY_AUTH_TOKEN=\"${token}\"\n"
  else
    config_content+="# AILY_DASHBOARD_URL=\"\"\n"
    config_content+="# AILY_AUTH_TOKEN=\"\"\n"
  fi

  printf '%b' "$config_content" > "$ENV_FILE"
  chmod 600 "$ENV_FILE"
  ok "Saved to ${ENV_FILE} (chmod 600)"
  echo ""

  # -- Install hooks --
  if [[ -x "${SCRIPT_DIR}/install.sh" ]]; then
    bash "${SCRIPT_DIR}/install.sh" 2>&1 | while IFS= read -r line; do
      echo "  $line"
    done
  else
    warn "install.sh not found at ${SCRIPT_DIR}/install.sh"
    info "Run install.sh manually to set up hooks"
  fi
  echo ""

  # -- Shell completions --
  local comp_dir
  if [[ -n "${ZSH_VERSION:-}" || "$SHELL" == */zsh ]]; then
    comp_dir="${ZDOTDIR:-$HOME}/.zfunc"
    mkdir -p "$comp_dir"
    if [[ -f "${SCRIPT_DIR}/completions/aily.zsh" ]]; then
      cp "${SCRIPT_DIR}/completions/aily.zsh" "${comp_dir}/_aily"
      ok "Zsh completions installed to ${comp_dir}/_aily"
      info "Add to .zshrc: fpath=(${comp_dir} \$fpath) && autoload -Uz compinit && compinit"
    else
      warn "Zsh completion script not found at ${SCRIPT_DIR}/completions/aily.zsh"
    fi
  else
    comp_dir="${BASH_COMPLETION_USER_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion/completions}"
    mkdir -p "$comp_dir"
    if [[ -f "${SCRIPT_DIR}/completions/aily.bash" ]]; then
      cp "${SCRIPT_DIR}/completions/aily.bash" "${comp_dir}/aily"
      ok "Bash completions installed to ${comp_dir}/aily"
    else
      warn "Bash completion script not found at ${SCRIPT_DIR}/completions/aily.bash"
    fi
  fi
  echo ""

  # -- Test notification --
  if [[ "$non_interactive" == "false" ]]; then
    if ui_confirm "Send a test notification?" "y"; then
      _send_test_notification
    else
      info "Skipped"
    fi
  fi

  echo ""
  hdr "Setup complete"
  echo ""
  info "Run 'aily status' to verify configuration"
  info "Run 'aily doctor' to diagnose issues"
  info "To add SSH hosts: aily config set SSH_HOSTS \"localhost,your-server\""
  echo ""
}

_start_local_dashboard() {
  local url="$1"
  local token="${2:-}"

  # Extract port from URL
  local port=8080
  if [[ "$url" =~ :([0-9]+) ]]; then
    port="${BASH_REMATCH[1]}"
  fi

  # Check if port is already in use
  if lsof -i ":${port}" >/dev/null 2>&1; then
    warn "Port ${port} is already in use"
    return 1
  fi

  # Detect available methods
  local _methods=() _descs=()
  if command -v uv >/dev/null 2>&1 && [[ -d "${SCRIPT_DIR}/dashboard" ]]; then
    _methods[${#_methods[@]}]="uv"
    _descs[${#_descs[@]}]="fast, recommended"
  fi
  if command -v pip3 >/dev/null 2>&1 || command -v pip >/dev/null 2>&1; then
    if [[ -d "${SCRIPT_DIR}/dashboard" ]]; then
      _methods[${#_methods[@]}]="pip"
      _descs[${#_descs[@]}]="classic"
    fi
  fi
  if command -v docker >/dev/null 2>&1; then
    _methods[${#_methods[@]}]="docker"
    _descs[${#_descs[@]}]="containerized, no local deps"
  fi

  if [[ ${#_methods[@]} -eq 0 ]]; then
    warn "No install method available (need uv, pip, or docker)"
    info "Install one of: uv (https://docs.astral.sh/uv), pip, docker"
    return 1
  fi

  # Let user choose if multiple methods available
  local method="${_methods[0]}"
  if [[ ${#_methods[@]} -gt 1 ]]; then
    local method_idx=0
    ui_select method_idx "Install method" "${_methods[@]}" -- "${_descs[@]}"
    method="${_methods[$method_idx]}"
  else
    info "Using ${method}"
  fi

  case "$method" in
    uv)     _dashboard_via_uv "$port" "$token" ;;
    pip)    _dashboard_via_pip "$port" "$token" ;;
    docker) _dashboard_via_docker "$port" "$token" ;;
  esac
}

_dashboard_via_uv() {
  local port="$1"
  local token="${2:-}"
  local venv_dir="${SCRIPT_DIR}/.venv"

  if [[ ! -d "$venv_dir" ]]; then
    info "Creating virtualenv..."
    uv venv "$venv_dir" >/dev/null 2>&1 || {
      warn "Failed to create virtualenv with uv"
      return 1
    }
  fi

  info "Installing dependencies with uv..."
  uv pip install -q -p "${venv_dir}/bin/python" \
    -r "${SCRIPT_DIR}/requirements.txt" 2>/dev/null || {
    warn "Failed to install dependencies with uv"
    return 1
  }
  ok "Dependencies installed"
  _dashboard_start_process "$port" "${venv_dir}/bin/python" "$token"
}

_dashboard_via_pip() {
  local port="$1"
  local token="${2:-}"
  local venv_dir="${SCRIPT_DIR}/.venv"

  if [[ ! -d "$venv_dir" ]]; then
    info "Creating virtualenv..."
    local py=""
    for cmd in python3 python; do
      command -v "$cmd" >/dev/null 2>&1 && { py="$cmd"; break; }
    done
    if [[ -z "$py" ]]; then
      warn "Python not found"
      return 1
    fi
    "$py" -m venv "$venv_dir" 2>/dev/null || {
      warn "Failed to create virtualenv"
      return 1
    }
  fi

  info "Installing dependencies with pip..."
  "${venv_dir}/bin/pip" install -q \
    -r "${SCRIPT_DIR}/requirements.txt" 2>/dev/null || {
    warn "Failed to install dependencies with pip"
    return 1
  }
  ok "Dependencies installed"
  _dashboard_start_process "$port" "${venv_dir}/bin/python" "$token"
}

_dashboard_via_docker() {
  local port="$1"
  local token="${2:-}"
  local image="aily-dashboard"

  info "Building Docker image..."
  if ! docker build -q -t "$image" "${SCRIPT_DIR}" >/dev/null 2>&1; then
    warn "Docker build failed"
    return 1
  fi
  ok "Image built"

  info "Starting container on port ${port}..."
  local cid
  cid=$(docker run -d --rm \
    --name aily-dashboard \
    -p "${port}:8080" \
    -v "${ENV_FILE}:/app/env:ro" \
    -e AGENT_BRIDGE_ENV=/app/env \
    ${token:+-e DASHBOARD_TOKEN="$token"} \
    "$image" 2>/dev/null) || {
    warn "Failed to start container"
    return 1
  }

  _dashboard_wait_healthy "http://localhost:${port}" || return 1
  ok "Dashboard running (container: ${cid:0:12})"
  info "Stop: docker stop aily-dashboard"
  return 0
}

_dashboard_start_process() {
  local port="$1"
  local py="${2:-}"
  local token="${3:-}"

  # Fallback: find system python if no venv python provided
  if [[ -z "$py" ]]; then
    for cmd in python3 python; do
      command -v "$cmd" >/dev/null 2>&1 && { py="$cmd"; break; }
    done
  fi
  if [[ -z "$py" ]]; then
    warn "Python not found"
    return 1
  fi

  # Local DB path (Docker uses /app/data, local uses ~/.local/share/aily)
  local db_dir="${HOME}/.local/share/aily"
  mkdir -p "$db_dir" 2>/dev/null || {
    db_dir="/tmp/aily-data"
    mkdir -p "$db_dir"
  }

  info "Starting dashboard on port ${port}..."
  PYTHONPATH="${SCRIPT_DIR}" \
    DASHBOARD_HOST="0.0.0.0" DASHBOARD_PORT="$port" \
    DASHBOARD_DB_PATH="${db_dir}/aily.db" \
    AGENT_BRIDGE_ENV="$ENV_FILE" \
    ${token:+DASHBOARD_TOKEN="$token"} \
    nohup "$py" -m dashboard >/tmp/aily-dashboard.log 2>&1 &
  local pid=$!

  _dashboard_wait_healthy "http://localhost:${port}" || {
    info "Check logs: /tmp/aily-dashboard.log"
    return 1
  }
  ok "Dashboard running (PID ${pid})"
  info "Logs: /tmp/aily-dashboard.log"
  info "Stop: kill ${pid}"
  return 0
}

_dashboard_wait_healthy() {
  local url="$1"
  local attempts=0
  while [[ $attempts -lt 15 ]]; do
    sleep 0.5
    if curl -sf --connect-timeout 1 "${url}/healthz" >/dev/null 2>&1; then
      return 0
    fi
    attempts=$((attempts + 1))
  done
  warn "Dashboard not responding after 7s"
  return 1
}

_send_test_notification() {
  load_env
  local timestamp
  timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  local hostname_short
  hostname_short=$(hostname -s 2>/dev/null || hostname)
  local message=":white_check_mark: *aily connected!*\n\n:desktop_computer: Host: \`${hostname_short}\`\n:clock1: Time: ${timestamp}\n\nAvailable commands:\n‚Ä¢ \`!new [name]\` ‚Äî Create a new tmux session\n‚Ä¢ \`!sessions\` ‚Äî List active sessions\n‚Ä¢ \`!send <session> <message>\` ‚Äî Send a message to a session"
  local any_ok=false

  # Post directly to channel (not thread) so it works outside tmux
  if [[ -n "${SLACK_BOT_TOKEN:-}" && -n "${SLACK_CHANNEL_ID:-}" ]]; then
    local payload
    payload=$(python3 -c "import json; print(json.dumps({'channel': '${SLACK_CHANNEL_ID}', 'text': '${message}', 'unfurl_links': False}))")
    local resp
    resp=$(curl -sf -X POST \
      -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
      -H "Content-Type: application/json; charset=utf-8" \
      -d "$payload" \
      "https://slack.com/api/chat.postMessage" 2>/dev/null || echo "")
    if echo "$resp" | jq -e '.ok == true' >/dev/null 2>&1; then
      any_ok=true
    fi
  fi

  if [[ -n "${DISCORD_BOT_TOKEN:-}" && -n "${DISCORD_CHANNEL_ID:-}" ]]; then
    local discord_msg="‚úÖ **aily connected!**\n\nüñ•Ô∏è Host: \`${hostname_short}\`\nüïê Time: ${timestamp}\n\nAvailable commands:\n‚Ä¢ \`!new [name]\` ‚Äî Create a new tmux session\n‚Ä¢ \`!sessions\` ‚Äî List active sessions\n‚Ä¢ \`!send <session> <message>\` ‚Äî Send a message to a session"
    local resp
    resp=$(curl -sf -X POST \
      -H "Authorization: Bot ${DISCORD_BOT_TOKEN}" \
      -H "Content-Type: application/json" \
      -d "{\"content\": \"${discord_msg}\"}" \
      "https://discord.com/api/v10/channels/${DISCORD_CHANNEL_ID}/messages" 2>/dev/null || echo "")
    if echo "$resp" | jq -e '.id' >/dev/null 2>&1; then
      any_ok=true
    fi
  fi

  if [[ "$any_ok" == "true" ]]; then
    ok "Test notification sent"
  else
    warn "Could not send test notification"
  fi
}

# -------------------------------------------------------------------
# aily status
# -------------------------------------------------------------------
cmd_status() {
  require_deps
  load_env

  hdr "aily status"

  # Dashboard
  printf "\n  ${C_BOLD}Dashboard${C_RESET}\n"
  local url
  url=$(dashboard_url)
  info "URL: ${url}"
  printf "  Connectivity: "
  if curl -sf --connect-timeout 3 "${url}/healthz" >/dev/null 2>&1; then
    printf "${C_GREEN}reachable${C_RESET}\n"
  else
    printf "${C_RED}unreachable${C_RESET}\n"
  fi

  local token
  token=$(dashboard_token)
  if [[ -n "$token" ]]; then
    printf "  Auth token: ${C_GREEN}set${C_RESET} ($(redact "$token"))\n"
  else
    printf "  Auth token: ${C_DIM}not set${C_RESET}\n"
  fi

  # Platforms
  printf "\n  ${C_BOLD}Platforms${C_RESET}\n"

  # Discord
  if [[ -n "${DISCORD_BOT_TOKEN:-}" && -n "${DISCORD_CHANNEL_ID:-}" ]]; then
    printf "  Discord: "
    local discord_resp
    discord_resp=$(curl -sf --connect-timeout 3 -H "Authorization: Bot ${DISCORD_BOT_TOKEN}" \
      "https://discord.com/api/v10/channels/${DISCORD_CHANNEL_ID}" 2>/dev/null || echo "")
    if [[ -n "$discord_resp" ]] && echo "$discord_resp" | jq -e '.id' >/dev/null 2>&1; then
      local chan_name
      chan_name=$(echo "$discord_resp" | jq -r '.name // "unknown"')
      printf "${C_GREEN}connected${C_RESET} (#%s)\n" "$chan_name"
    else
      printf "${C_YELLOW}configured but unreachable${C_RESET}\n"
    fi
  else
    printf "  Discord: ${C_DIM}not configured${C_RESET}\n"
  fi

  # Slack
  if [[ -n "${SLACK_BOT_TOKEN:-}" && -n "${SLACK_CHANNEL_ID:-}" ]]; then
    printf "  Slack: "
    local slack_resp
    slack_resp=$(curl -sf --connect-timeout 3 -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
      "https://slack.com/api/conversations.info?channel=${SLACK_CHANNEL_ID}" 2>/dev/null || echo "")
    if [[ -n "$slack_resp" ]] && echo "$slack_resp" | jq -e '.ok == true' >/dev/null 2>&1; then
      local chan_name
      chan_name=$(echo "$slack_resp" | jq -r '.channel.name // "unknown"')
      printf "${C_GREEN}connected${C_RESET} (#%s)\n" "$chan_name"
    else
      printf "${C_YELLOW}configured but unreachable${C_RESET}\n"
    fi
  else
    printf "  Slack: ${C_DIM}not configured${C_RESET}\n"
  fi

  # SSH hosts
  printf "\n  ${C_BOLD}SSH hosts${C_RESET}\n"
  local hosts_str
  hosts_str=$(env_get "SSH_HOSTS" "localhost")
  IFS=',' read -ra hosts <<< "$hosts_str"
  for host in "${hosts[@]}"; do
    host=$(echo "$host" | tr -d ' ')
    printf "  %s: " "$host"
    if [[ "$host" == "localhost" ]]; then
      printf "${C_GREEN}local${C_RESET}\n"
    elif ssh -o ConnectTimeout=2 -o BatchMode=yes "$host" "echo ok" >/dev/null 2>&1; then
      printf "${C_GREEN}reachable${C_RESET}\n"
    else
      printf "${C_RED}unreachable${C_RESET}\n"
    fi
  done

  # Hooks
  printf "\n  ${C_BOLD}Installed hooks${C_RESET}\n"
  local hook_files=(notify-claude.sh notify-gemini.sh notify-codex.py notify-opencode.mjs post.sh thread-sync.sh discord-lib.sh slack-lib.sh)
  for hf in "${hook_files[@]}"; do
    local target="${HOOKS_DIR}/${hf}"
    if [[ -L "$target" ]]; then
      ok "$hf (symlink)"
    elif [[ -f "$target" ]]; then
      ok "$hf (file)"
    else
      printf "  ${C_DIM}¬∑ %s (missing)${C_RESET}\n" "$hf"
    fi
  done

  # Agent integrations
  printf "\n  ${C_BOLD}Agent integrations${C_RESET}\n"
  local claude_settings="$HOME/.claude/settings.json"
  if [[ -f "$claude_settings" ]] && grep -q "notify-clawdia\|notify-claude" "$claude_settings" 2>/dev/null; then
    ok "Claude Code (settings.json)"
  else
    printf "  ${C_DIM}¬∑ Claude Code (not configured)${C_RESET}\n"
  fi

  local codex_config="$HOME/.codex/config.toml"
  if [[ -f "$codex_config" ]] && grep -q "notify-codex" "$codex_config" 2>/dev/null; then
    ok "Codex CLI (config.toml)"
  else
    printf "  ${C_DIM}¬∑ Codex CLI (not configured)${C_RESET}\n"
  fi

  local gemini_settings="$HOME/.gemini/settings.json"
  if [[ -f "$gemini_settings" ]] && grep -q "notify-gemini" "$gemini_settings" 2>/dev/null; then
    ok "Gemini CLI (settings.json)"
  else
    printf "  ${C_DIM}¬∑ Gemini CLI (not configured)${C_RESET}\n"
  fi

  local opencode_plugins="$HOME/.config/opencode/plugins"
  if [[ -d "$opencode_plugins" ]] && find "$opencode_plugins" -maxdepth 1 \( -name "aily*" -o -name "notify-opencode*" \) -print -quit | grep -q .; then
    ok "OpenCode (plugin)"
  else
    printf "  ${C_DIM}¬∑ OpenCode (not configured)${C_RESET}\n"
  fi

  # tmux
  printf "\n  ${C_BOLD}tmux${C_RESET}\n"
  local sync_status
  sync_status=$(env_get "TMUX_THREAD_SYNC" "true")
  info "Thread sync: ${sync_status}"
  local cleanup_status
  cleanup_status=$(env_get "THREAD_CLEANUP" "archive")
  info "Thread cleanup: ${cleanup_status}"
  if command -v tmux >/dev/null 2>&1 && tmux list-sessions >/dev/null 2>&1; then
    local session_count
    session_count=$(tmux list-sessions 2>/dev/null | wc -l | tr -d ' ')
    info "Active tmux sessions: ${session_count}"
  else
    info "tmux: not running"
  fi

  echo ""
}

# -------------------------------------------------------------------
# aily sessions
# -------------------------------------------------------------------
cmd_sessions() {
  require_deps

  local output_json="${AILY_JSON}"
  local source="dashboard"  # default: try dashboard first, fall back to ssh

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json) output_json=true; shift ;;
      --ssh)  source="ssh"; shift ;;
      *) shift ;;
    esac
  done

  if [[ "$source" == "ssh" ]]; then
    _sessions_ssh "$output_json"
    return
  fi

  # Try dashboard API first
  local resp
  resp=$(api_call GET "/api/sessions?status=active" 2>/dev/null || echo "")

  if [[ -n "$resp" ]] && echo "$resp" | jq -e '.' >/dev/null 2>&1; then
    if json_output "$resp"; then
      return
    fi
    if [[ "$output_json" == "true" ]]; then
      printf '%s\n' "$resp"
      return
    fi

    local count
    count=$(echo "$resp" | jq 'if type == "array" then length else (.sessions // []) | length end')
    if [[ "$count" == "0" || "$count" == "null" ]]; then
      info "No active sessions"
      return
    fi

    hdr "Active sessions (${count})"
    echo ""
    printf "  ${C_BOLD}%-24s %-16s %-10s %-10s %s${C_RESET}\n" "NAME" "HOST" "STATUS" "AGENT" "UPDATED"
    printf "  %-24s %-16s %-10s %-10s %s\n" "------------------------" "----------------" "----------" "----------" "-------------------"

    # Handle both array and object-with-sessions response formats
    echo "$resp" | jq -r '
      (if type == "array" then . else (.sessions // []) end)[]
      | [
          (.name // "-"),
          (.host // "-"),
          (.status // "-"),
          (.agent_type // "-"),
          (.updated_at // "-" | split("T") | if length > 1 then .[0] + " " + (.[1] | split(".")[0]) else .[0] end)
        ]
      | @tsv
    ' 2>/dev/null | while IFS=$'\t' read -r name host status agent updated; do
      local status_color="$C_RESET"
      case "$status" in
        active)   status_color="$C_GREEN" ;;
        idle)     status_color="$C_YELLOW" ;;
        closed)   status_color="$C_DIM" ;;
      esac
      printf "  %-24s %-16s ${status_color}%-10s${C_RESET} %-10s %s\n" \
        "$name" "$host" "$status" "$agent" "$updated"
    done
    echo ""
  else
    # Fall back to SSH-based session listing
    if [[ "$output_json" != "true" && "$AILY_JSON" != true ]]; then
      info "Dashboard unavailable, falling back to SSH..."
    fi
    _sessions_ssh "$output_json"
  fi
}

_sessions_ssh() {
  local json_output="${1:-false}"
  load_env

  local hosts_str
  hosts_str=$(env_get "SSH_HOSTS" "localhost")
  IFS=',' read -ra hosts <<< "$hosts_str"

  if [[ "$json_output" == "true" ]]; then
    echo "["
    local first=true
    for host in "${hosts[@]}"; do
      host=$(echo "$host" | tr -d ' ')
      local sessions
      if [[ "$host" == "localhost" ]]; then
        sessions=$(tmux list-sessions -F '#{session_name}' 2>/dev/null || echo "")
      else
        sessions=$(ssh -o ConnectTimeout=3 -o BatchMode=yes "$host" \
          "tmux list-sessions -F '#{session_name}' 2>/dev/null" 2>/dev/null || echo "")
      fi
      while IFS= read -r name; do
        [[ -z "$name" ]] && continue
        if [[ "$first" == "true" ]]; then first=false; else echo ","; fi
        printf '  {"name": "%s", "host": "%s"}' "$name" "$host"
      done <<< "$sessions"
    done
    echo ""
    echo "]"
    return
  fi

  hdr "tmux sessions (via SSH)"
  echo ""

  for host in "${hosts[@]}"; do
    host=$(echo "$host" | tr -d ' ')
    local sessions
    if [[ "$host" == "localhost" ]]; then
      sessions=$(tmux list-sessions -F '#{session_name}' 2>/dev/null || echo "")
    else
      sessions=$(ssh -o ConnectTimeout=3 -o BatchMode=yes "$host" \
        "tmux list-sessions -F '#{session_name}' 2>/dev/null" 2>/dev/null || echo "")
    fi
    if [[ -n "$sessions" ]]; then
      printf "  ${C_BOLD}%s${C_RESET}\n" "$host"
      while IFS= read -r name; do
        [[ -z "$name" ]] && continue
        echo "    $name"
      done <<< "$sessions"
      echo ""
    else
      printf "  ${C_DIM}%s (no sessions)${C_RESET}\n" "$host"
    fi
  done
}

# -------------------------------------------------------------------
# aily sync [session-name]
# -------------------------------------------------------------------
cmd_sync() {
  require_deps

  local session_name="${1:-}"
  if [[ -z "$session_name" ]]; then
    session_name=$(detect_tmux_session)
  fi
  if [[ -z "$session_name" ]]; then
    err "No session name provided and not inside tmux"
    echo "  Usage: aily sync <session-name>" >&2
    exit 1
  fi

  printf "  Syncing session '%s'... " "$session_name"
  local resp
  resp=$(api_call POST "/api/sessions/${session_name}/sync" 2>/dev/null || echo "")

  if [[ -n "$resp" ]]; then
    local count
    count=$(echo "$resp" | jq -r '.synced_messages // .count // "unknown"' 2>/dev/null)
    printf "${C_GREEN}OK${C_RESET}\n"
    info "Synced messages: ${count}"
  else
    printf "${C_RED}FAILED${C_RESET}\n"
    err "Could not sync session. Is the dashboard reachable?"
  fi
}

# -------------------------------------------------------------------
# aily logs [session-name]
# -------------------------------------------------------------------
cmd_logs() {
  require_deps

  local session_name="" limit=20 json_output=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json)    json_output=true; shift ;;
      --limit)   limit="$2"; shift 2 ;;
      -n)        limit="$2"; shift 2 ;;
      -*)        shift ;;
      *)
        if [[ -z "$session_name" ]]; then
          session_name="$1"
        fi
        shift
        ;;
    esac
  done

  if [[ -z "$session_name" ]]; then
    session_name=$(detect_tmux_session)
  fi
  if [[ -z "$session_name" ]]; then
    err "No session name provided and not inside tmux"
    echo "  Usage: aily logs <session-name>" >&2
    exit 1
  fi

  local resp
  resp=$(api_call GET "/api/sessions/${session_name}/messages?limit=${limit}" 2>/dev/null || echo "")

  if [[ -z "$resp" ]]; then
    err "Could not fetch messages. Is the dashboard reachable?"
    exit 1
  fi

  if [[ "$json_output" == "true" ]]; then
    echo "$resp" | jq .
    return
  fi

  local count
  count=$(echo "$resp" | jq 'if type == "array" then length else (.messages // []) | length end' 2>/dev/null)

  if [[ "$count" == "0" || "$count" == "null" || -z "$count" ]]; then
    info "No messages for session '${session_name}'"
    return
  fi

  hdr "Messages for ${session_name} (${count})"
  echo ""

  echo "$resp" | jq -r '
    (if type == "array" then . else (.messages // []) end)[]
    | "\(.role // "unknown")\t\(.content // "")\t\(.created_at // "-")"
  ' 2>/dev/null | while IFS=$'\t' read -r role content timestamp; do
    local role_color="$C_RESET"
    local role_label="$role"
    case "$role" in
      user|human)     role_color="$C_BLUE"; role_label="user" ;;
      assistant|ai)   role_color="$C_GREEN"; role_label="assistant" ;;
      system)         role_color="$C_MAGENTA"; role_label="system" ;;
      tool)           role_color="$C_CYAN"; role_label="tool" ;;
    esac

    local ts_short
    ts_short=$(echo "$timestamp" | sed 's/T/ /; s/\..*//')
    printf "  ${C_DIM}%s${C_RESET} ${role_color}${C_BOLD}[%s]${C_RESET} %s\n" \
      "$ts_short" "$role_label" "$content"
  done
  echo ""
}

# -------------------------------------------------------------------
# aily attach [session-name]
# -------------------------------------------------------------------
cmd_attach() {
  require_cmd tmux "install via your package manager" || return 1

  local session_name="${1:-}"
  if [[ -z "$session_name" ]]; then
    printf "${C_BOLD}Active tmux sessions:${C_RESET}\n"
    tmux list-sessions 2>/dev/null || { err "No tmux sessions found"; return 1; }
    printf "\n"
    read -rp "Session name: " session_name
    [[ -z "$session_name" ]] && return 1
  fi

  if tmux has-session -t "$session_name" 2>/dev/null; then
    exec tmux attach-session -t "$session_name"
  else
    err "Session '$session_name' not found"
    return 1
  fi
}

# -------------------------------------------------------------------
# aily export <session-name> [json|markdown]
# -------------------------------------------------------------------
cmd_export() {
  require_cmd curl "install via your package manager" || return 1

  local session_name="${1:-}"
  local format="${2:-markdown}"

  if [[ -z "$session_name" ]]; then
    err "Usage: aily export <session-name> [json|markdown]"
    return 1
  fi

  case "$format" in
    json|markdown) ;;
    *)
      err "Invalid format '${format}'. Use: json or markdown"
      return 1
      ;;
  esac

  local dashboard_url_value
  dashboard_url_value="$(dashboard_url)"
  if [[ -z "$dashboard_url_value" ]]; then
    err "Dashboard URL not configured. Run: aily config set dashboard_url <url>"
    return 1
  fi

  local token
  token="$(dashboard_token)"

  # Build a safe local filename from session name to prevent path traversal.
  local output_stem="$session_name"
  output_stem="${output_stem##*/}"
  output_stem="${output_stem##*\\}"
  output_stem="$(printf '%s' "$output_stem" | tr -c 'A-Za-z0-9._-:' '_')"
  if [[ -z "$output_stem" || "$output_stem" == "." || "$output_stem" == ".." ]]; then
    output_stem="session"
  fi

  local output_file
  if [[ "$format" == "json" ]]; then
    output_file="${output_stem}.json"
  else
    output_file="${output_stem}.md"
  fi

  local session_name_encoded
  if command -v python3 >/dev/null 2>&1; then
    session_name_encoded="$(python3 -c 'import sys, urllib.parse; print(urllib.parse.quote(sys.argv[1], safe=""))' "$session_name" 2>/dev/null || echo "")"
  elif command -v jq >/dev/null 2>&1; then
    session_name_encoded="$(jq -rn --arg v "$session_name" '$v|@uri' 2>/dev/null || echo "")"
  fi
  if [[ -z "$session_name_encoded" ]]; then
    err "Could not encode session name for export URL (requires python3 or jq)"
    return 1
  fi

  printf "Exporting session '%s' as %s...\n" "$session_name" "$format"

  local curl_args=(-sf)
  if [[ -n "$token" ]]; then
    curl_args+=(-H "Authorization: Bearer $token")
  fi

  if curl "${curl_args[@]}" "${dashboard_url_value}/api/sessions/${session_name_encoded}/export?format=${format}" -o "$output_file"; then
    if [[ -f "$output_file" ]]; then
      ok "Exported to $output_file ($(wc -c < "$output_file" | tr -d ' ') bytes)"
      return 0
    fi
  fi

  err "Export failed"
  return 1
}

# -------------------------------------------------------------------
# aily config
# -------------------------------------------------------------------
cmd_config() {
  local subcmd="${1:-show}"
  shift 2>/dev/null || true

  case "$subcmd" in
    show)
      _config_show
      ;;
    set)
      _config_set "$@"
      ;;
    dashboard-url)
      local new_url="${1:-}"
      if [[ -z "$new_url" ]]; then
        err "Usage: aily config dashboard-url <URL>"
        exit 1
      fi
      env_set "AILY_DASHBOARD_URL" "$new_url"
      ok "AILY_DASHBOARD_URL = ${new_url}"
      ;;
    *)
      err "Unknown config subcommand: ${subcmd}"
      echo "  Usage:" >&2
      echo "    aily config show                  Show current configuration" >&2
      echo "    aily config set KEY VALUE         Set a configuration key" >&2
      echo "    aily config dashboard-url URL     Shortcut for dashboard URL" >&2
      exit 1
      ;;
  esac
}

_config_show() {
  if [[ ! -f "$ENV_FILE" ]]; then
    err "No configuration file found at ${ENV_FILE}"
    info "Run 'aily init' to create one"
    exit 1
  fi

  hdr "Configuration (${ENV_FILE})"
  echo ""

  # Read and redact sensitive values
  local secret_keys="DISCORD_BOT_TOKEN SLACK_BOT_TOKEN SLACK_APP_TOKEN AILY_AUTH_TOKEN TELEGRAM_BOT_TOKEN"
  while IFS= read -r line; do
    # Skip empty lines and comments ‚Äî print as-is
    if [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]]; then
      echo "  $line"
      continue
    fi
    if [[ "$line" =~ ^([A-Z_]+)=(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local val="${BASH_REMATCH[2]}"
      # Strip quotes
      val="${val#\"}"
      val="${val%\"}"
      val="${val#\'}"
      val="${val%\'}"

      if [[ " $secret_keys " == *" $key "* && -n "$val" ]]; then
        printf "  ${C_CYAN}%s${C_RESET}=%s\n" "$key" "$(redact "$val")"
      else
        printf "  ${C_CYAN}%s${C_RESET}=%s\n" "$key" "$val"
      fi
    else
      echo "  $line"
    fi
  done < "$ENV_FILE"
  echo ""
}

_config_set() {
  local key="${1:-}" value="${2:-}"
  if [[ -z "$key" || -z "$value" ]]; then
    err "Usage: aily config set KEY VALUE"
    exit 1
  fi
  # Normalize key to uppercase
  key=$(echo "$key" | tr '[:lower:]' '[:upper:]')
  env_set "$key" "$value"
  ok "${key} updated"
}

# -------------------------------------------------------------------
# aily doctor
# -------------------------------------------------------------------
cmd_doctor() {
  require_deps

  hdr "aily doctor"
  local issues=0

  # Dependencies
  printf "\n  ${C_BOLD}Dependencies${C_RESET}\n"
  for cmd in curl jq tmux ssh python3; do
    if command -v "$cmd" >/dev/null 2>&1; then
      local ver
      case "$cmd" in
        curl)    ver=$(curl --version 2>/dev/null | head -1 | awk '{print $2}') ;;
        jq)      ver=$(jq --version 2>/dev/null | tr -d 'jq-') ;;
        tmux)    ver=$(tmux -V 2>/dev/null | awk '{print $2}') ;;
        ssh)     ver=$(ssh -V 2>&1 | awk '{print $1}') ;;
        python3) ver=$(python3 --version 2>/dev/null | awk '{print $2}') ;;
      esac
      ok "$cmd (${ver:-installed})"
    else
      if [[ "$cmd" == "curl" || "$cmd" == "jq" ]]; then
        err "$cmd NOT FOUND (required)"
        issues=$((issues + 1))
      else
        warn "$cmd not found (optional)"
      fi
    fi
  done

  # Config file
  printf "\n  ${C_BOLD}Configuration${C_RESET}\n"
  if [[ -f "$ENV_FILE" ]]; then
    ok "Config exists at ${ENV_FILE}"
    local perms
    perms=$(stat -f '%Lp' "$ENV_FILE" 2>/dev/null || stat -c '%a' "$ENV_FILE" 2>/dev/null || echo "unknown")
    if [[ "$perms" == "600" ]]; then
      ok "Permissions: ${perms}"
    else
      warn "Permissions: ${perms} (expected 600)"
      issues=$((issues + 1))
    fi
  else
    err "Config not found at ${ENV_FILE}"
    info "Run 'aily init' to create it"
    issues=$((issues + 1))
  fi

  # Dashboard
  printf "\n  ${C_BOLD}Dashboard${C_RESET}\n"
  local url
  url=$(dashboard_url)
  printf "  Checking %s... " "$url"
  if curl -sf --connect-timeout 5 "${url}/healthz" >/dev/null 2>&1; then
    printf "${C_GREEN}OK${C_RESET}\n"
  else
    printf "${C_RED}UNREACHABLE${C_RESET}\n"
    issues=$((issues + 1))
  fi

  local token
  token=$(dashboard_token)
  if [[ -n "$token" ]]; then
    printf "  Checking auth... "
    if curl -sf --connect-timeout 5 -H "Authorization: Bearer ${token}" "${url}/api/stats" >/dev/null 2>&1; then
      printf "${C_GREEN}OK${C_RESET}\n"
    else
      printf "${C_YELLOW}FAILED${C_RESET} (token may be invalid or dashboard unavailable)\n"
      issues=$((issues + 1))
    fi
  else
    info "No auth token configured"
  fi

  # Platform APIs
  printf "\n  ${C_BOLD}Platform APIs${C_RESET}\n"
  load_env

  if [[ -n "${DISCORD_BOT_TOKEN:-}" && -n "${DISCORD_CHANNEL_ID:-}" ]]; then
    printf "  Discord API... "
    local discord_resp
    discord_resp=$(curl -sf --connect-timeout 5 -H "Authorization: Bot ${DISCORD_BOT_TOKEN}" \
      "https://discord.com/api/v10/channels/${DISCORD_CHANNEL_ID}" 2>/dev/null || echo "")
    if [[ -n "$discord_resp" ]] && echo "$discord_resp" | jq -e '.id' >/dev/null 2>&1; then
      printf "${C_GREEN}OK${C_RESET}\n"
    else
      printf "${C_RED}FAILED${C_RESET}\n"
      issues=$((issues + 1))
    fi
  else
    info "Discord: not configured"
  fi

  if [[ -n "${SLACK_BOT_TOKEN:-}" && -n "${SLACK_CHANNEL_ID:-}" ]]; then
    printf "  Slack API... "
    local slack_resp
    slack_resp=$(curl -sf --connect-timeout 5 -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
      "https://slack.com/api/auth.test" 2>/dev/null || echo "")
    if [[ -n "$slack_resp" ]] && echo "$slack_resp" | jq -e '.ok == true' >/dev/null 2>&1; then
      printf "${C_GREEN}OK${C_RESET}\n"
    else
      printf "${C_RED}FAILED${C_RESET}\n"
      issues=$((issues + 1))
    fi
  else
    info "Slack: not configured"
  fi

  # Hook symlinks
  printf "\n  ${C_BOLD}Hook symlinks${C_RESET}\n"
  local expected_hooks=(notify-claude.sh notify-gemini.sh notify-codex.py notify-opencode.mjs post.sh thread-sync.sh discord-lib.sh slack-lib.sh)
  for hf in "${expected_hooks[@]}"; do
    local target="${HOOKS_DIR}/${hf}"
    if [[ -L "$target" ]]; then
      local link_target
      link_target=$(readlink "$target" 2>/dev/null || echo "unknown")
      if [[ -f "$link_target" ]]; then
        ok "$hf -> $link_target"
      else
        err "$hf -> $link_target (BROKEN symlink)"
        issues=$((issues + 1))
      fi
    elif [[ -f "$target" ]]; then
      ok "$hf (regular file)"
    else
      warn "$hf (missing)"
    fi
  done

  # Agent configurations
  printf "\n  ${C_BOLD}Agent configurations${C_RESET}\n"

  # Claude Code
  local claude_settings="$HOME/.claude/settings.json"
  if [[ -f "$claude_settings" ]]; then
    if grep -q "notify-clawdia\|notify-claude" "$claude_settings" 2>/dev/null; then
      ok "Claude Code: hook configured in settings.json"
    else
      warn "Claude Code: settings.json exists but no aily hook found"
      issues=$((issues + 1))
    fi
  else
    info "Claude Code: settings.json not found"
  fi

  # Codex CLI
  local codex_config="$HOME/.codex/config.toml"
  if [[ -f "$codex_config" ]]; then
    if grep -q "notify-codex" "$codex_config" 2>/dev/null; then
      ok "Codex CLI: hook configured in config.toml"
    else
      warn "Codex CLI: config.toml exists but no aily hook found"
      issues=$((issues + 1))
    fi
  else
    info "Codex CLI: config.toml not found"
  fi

  # Gemini CLI
  local gemini_settings="$HOME/.gemini/settings.json"
  if [[ -f "$gemini_settings" ]]; then
    if grep -q "notify-gemini" "$gemini_settings" 2>/dev/null; then
      ok "Gemini CLI: hook configured in settings.json"
    else
      warn "Gemini CLI: settings.json exists but no aily hook found"
      issues=$((issues + 1))
    fi
  else
    info "Gemini CLI: settings.json not found"
  fi

  # OpenCode
  local opencode_plugins="$HOME/.config/opencode/plugins"
  if [[ -d "$opencode_plugins" ]]; then
    if find "$opencode_plugins" -maxdepth 1 \( -name "aily*" -o -name "notify-opencode*" \) -print -quit | grep -q .; then
      ok "OpenCode: plugin installed"
    else
      warn "OpenCode: plugins dir exists but no aily plugin found"
    fi
  else
    info "OpenCode: plugins dir not found"
  fi

  # Summary
  echo ""
  if [[ $issues -eq 0 ]]; then
    printf "  ${C_GREEN}${C_BOLD}No issues found.${C_RESET}\n"
  else
    printf "  ${C_YELLOW}${C_BOLD}Found %d issue(s).${C_RESET}\n" "$issues"
  fi
  echo ""
}

# -------------------------------------------------------------------
# aily start [name]
# -------------------------------------------------------------------
cmd_start() {
  local session_name="${1:-}"
  if [[ -z "$session_name" ]]; then
    session_name=$(detect_tmux_session)
  fi
  if [[ -z "$session_name" ]]; then
    err "Not inside tmux. Provide a session name: aily start <name>"
    exit 1
  fi

  local thread_name="[agent] ${session_name}"
  local hostname_short
  hostname_short=$(hostname -s 2>/dev/null || hostname)
  local timestamp
  timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  local any_ok=false

  info "Starting thread for ${session_name}..."

  if load_discord_env 2>/dev/null; then
    local thread_id
    thread_id=$(discord_ensure_thread "$thread_name" "tmux session: ${thread_name} (${hostname_short})")
    if [[ -n "$thread_id" ]]; then
      discord_post_to_thread "$thread_id" "Session \`${session_name}\` started on \`${hostname_short}\` ¬∑ ${timestamp}"
      ok "[discord] Thread ready"
      any_ok=true
    else
      err "[discord] Failed to create thread"
    fi
  fi

  if load_slack_env 2>/dev/null; then
    local thread_ts
    thread_ts=$(slack_ensure_thread "$thread_name" "tmux session: ${thread_name} (${hostname_short})")
    if [[ -n "$thread_ts" ]]; then
      slack_post_to_thread "$thread_ts" "Session \`${session_name}\` started on \`${hostname_short}\` ¬∑ ${timestamp}"
      ok "[slack] Thread ready"
      any_ok=true
    else
      err "[slack] Failed to create thread"
    fi
  fi

  if [[ "$any_ok" == false ]]; then
    err "No platforms configured. Check ${ENV_FILE}"
    exit 1
  fi
}

# -------------------------------------------------------------------
# aily stop [name]
# -------------------------------------------------------------------
cmd_stop() {
  local session_name="${1:-}"
  if [[ -z "$session_name" ]]; then
    session_name=$(detect_tmux_session)
  fi
  if [[ -z "$session_name" ]]; then
    err "Not inside tmux. Provide a session name: aily stop <name>"
    exit 1
  fi

  local thread_name="[agent] ${session_name}"
  local hostname_short
  hostname_short=$(hostname -s 2>/dev/null || hostname)
  local timestamp
  timestamp=$(date '+%Y-%m-%d %H:%M:%S')

  load_env
  local cleanup_mode
  cleanup_mode=$(env_get "THREAD_CLEANUP" "archive")

  info "Stopping thread for ${session_name} (${cleanup_mode})..."

  if load_discord_env 2>/dev/null; then
    local thread_id
    thread_id=$(discord_find_thread "$thread_name")
    if [[ -n "$thread_id" ]]; then
      discord_post_to_thread "$thread_id" "Session \`${session_name}\` stopped on \`${hostname_short}\` ¬∑ ${timestamp}"
      if [[ "$cleanup_mode" == "delete" ]]; then
        discord_delete_thread "$thread_id"
        ok "[discord] Thread deleted"
      else
        discord_archive_thread "$thread_id"
        ok "[discord] Thread archived"
      fi
    else
      info "[discord] No thread found"
    fi
  fi

  if load_slack_env 2>/dev/null; then
    local thread_ts
    thread_ts=$(slack_find_thread "$thread_name")
    if [[ -n "$thread_ts" ]]; then
      slack_post_to_thread "$thread_ts" "Session \`${session_name}\` stopped on \`${hostname_short}\` ¬∑ ${timestamp}"
      if [[ "$cleanup_mode" == "delete" ]]; then
        slack_delete_thread "$thread_ts"
        ok "[slack] Thread deleted"
      else
        slack_archive_thread "$thread_ts"
        ok "[slack] Thread archived"
      fi
    else
      info "[slack] No thread found"
    fi
  fi
}

# -------------------------------------------------------------------
# aily auto [on|off]
# -------------------------------------------------------------------
cmd_auto() {
  local action="${1:-}"
  case "$action" in
    on)
      env_set "TMUX_THREAD_SYNC" "true"
      ok "Auto thread sync: ON"
      ;;
    off)
      env_set "TMUX_THREAD_SYNC" "false"
      ok "Auto thread sync: OFF"
      ;;
    "")
      local current
      current=$(env_get "TMUX_THREAD_SYNC" "true")
      if [[ "$current" == "false" ]]; then
        info "Auto thread sync: OFF"
      else
        info "Auto thread sync: ON"
      fi
      ;;
    *)
      echo "Usage: aily auto [on|off]" >&2
      exit 1
      ;;
  esac
}

# -------------------------------------------------------------------
# aily usage
# -------------------------------------------------------------------

cmd_usage() {
  require_deps

  local subcmd="${1:-}"
  shift 2>/dev/null || true

  case "$subcmd" in
    queue)
      _usage_queue "$@"
      return
      ;;
  esac

  # Default: show current usage
  local resp
  resp=$(api_call GET "/api/usage" 2>/dev/null || echo "")

  if [[ -z "$resp" ]]; then
    err "Dashboard unavailable"
    return 1
  fi

  if json_output "$resp"; then return; fi

  hdr "API Usage (Rate Limits)"
  echo ""

  # Parse providers from response
  local providers
  providers=$(echo "$resp" | jq -r '.usage // {} | keys[]' 2>/dev/null)

  if [[ -z "$providers" ]]; then
    info "No usage data available. Enable USAGE_POLLER in dashboard settings."
    echo ""
    return
  fi

  for provider in $providers; do
    # Single jq call to extract all fields at once
    local -a fields
    mapfile -t fields < <(echo "$resp" | jq -r ".usage[\"$provider\"] |
      (.poll_status_code // \"?\"),
      (.polled_at // \"-\"),
      (.requests_remaining // \"?\"),
      (.requests_limit // \"?\"),
      (.input_tokens_remaining // \"?\"),
      (.input_tokens_limit // \"?\"),
      (.output_tokens_remaining // \"?\"),
      (.output_tokens_limit // \"?\"),
      (.tokens_remaining // \"?\"),
      (.tokens_limit // \"?\"),
      (.error_message // empty)")
    local status_code="${fields[0]:-?}"
    local polled_at
    polled_at=$(echo "${fields[1]:--}" | sed 's/T/ /;s/\..*//')
    local req_rem="${fields[2]:-?}" req_lim="${fields[3]:-?}"
    local in_rem="${fields[4]:-?}" in_lim="${fields[5]:-?}"
    local out_rem="${fields[6]:-?}" out_lim="${fields[7]:-?}"
    local tok_rem="${fields[8]:-?}" tok_lim="${fields[9]:-?}"
    local err_msg="${fields[10]:-}"

    printf "  ${C_BOLD}${C_CYAN}%s${C_RESET}  ${C_DIM}(polled: %s, status: %s)${C_RESET}\n" \
      "$provider" "$polled_at" "$status_code"

    printf "    Requests:      %s / %s remaining\n" "$req_rem" "$req_lim"

    if [[ "$in_rem" != "?" && "$in_rem" != "null" ]]; then
      printf "    Input tokens:  %s / %s remaining\n" "$in_rem" "$in_lim"
    fi

    if [[ "$out_rem" != "?" && "$out_rem" != "null" ]]; then
      printf "    Output tokens: %s / %s remaining\n" "$out_rem" "$out_lim"
    fi

    if [[ "$tok_rem" != "?" && "$tok_rem" != "null" ]]; then
      printf "    Tokens:        %s / %s remaining\n" "$tok_rem" "$tok_lim"
    fi

    if [[ -n "$err_msg" ]]; then
      printf "    ${C_RED}Error: %s${C_RESET}\n" "$err_msg"
    fi
    echo ""
  done

  # Queue stats
  local pending
  pending=$(echo "$resp" | jq -r '.queue_stats.pending // 0')
  if [[ "$pending" != "0" ]]; then
    printf "  ${C_YELLOW}Command queue: %s pending${C_RESET}\n" "$pending"
    info "Run: aily usage queue"
    echo ""
  fi
}

_usage_queue() {
  local action="${1:-}"

  case "$action" in
    add)
      # aily usage queue add <session> <command>
      local session="${2:-}"
      local command="${*:3}"
      if [[ -z "$session" || -z "$command" ]]; then
        echo "Usage: aily usage queue add <session-name> <command>" >&2
        return 1
      fi
      local resp
      resp=$(api_call POST "/api/usage/queue" \
        -d "$(jq -n --arg s "$session" --arg c "$command" '{"session_name":$s, "command":$c}')" 2>/dev/null || echo "")
      if [[ -z "$resp" ]]; then
        err "Failed to enqueue command"
        return 1
      fi
      if json_output "$resp"; then return; fi
      ok "Command queued for session '$session'"
      ;;
    execute)
      local resp
      resp=$(api_call POST "/api/usage/queue/execute" 2>/dev/null || echo "")
      if [[ -z "$resp" ]]; then
        err "Failed to execute queue"
        return 1
      fi
      if json_output "$resp"; then return; fi
      local count
      count=$(echo "$resp" | jq -r '.executed // 0')
      ok "Executed $count queued commands"
      ;;
    *)
      # List queue (default)
      local resp
      resp=$(api_call GET "/api/usage/queue?status=pending" 2>/dev/null || echo "")
      if [[ -z "$resp" ]]; then
        err "Dashboard unavailable"
        return 1
      fi
      if json_output "$resp"; then return; fi

      local total
      total=$(echo "$resp" | jq -r '.total // 0')
      hdr "Command Queue (${total} pending)"
      echo ""

      if [[ "$total" == "0" ]]; then
        info "No pending commands"
        echo ""
        return
      fi

      printf "  ${C_BOLD}%-6s %-24s %-12s %s${C_RESET}\n" "ID" "SESSION" "HOST" "COMMAND"
      printf "  %-6s %-24s %-12s %s\n" "------" "------------------------" "------------" "----------------------------"

      echo "$resp" | jq -r '.commands[] | [(.id|tostring), .session_name, .host, .command] | @tsv' 2>/dev/null | \
        while IFS=$'\t' read -r id session host command; do
          printf "  %-6s %-24s %-12s %s\n" "$id" "$session" "$host" "$command"
        done
      echo ""
      ;;
  esac
}

# -------------------------------------------------------------------
# aily deploy
# -------------------------------------------------------------------
cmd_deploy() {
  local host="${1:-}"
  if [[ -z "$host" ]]; then
    err "Usage: aily deploy <host>"
    exit 1
  fi

  require_deps
  load_env

  hdr "aily deploy ‚Üí ${host}"
  echo ""

  # 1. Test SSH
  if ! ui_spin "Testing SSH to ${host}" \
    ssh -o ConnectTimeout=5 -o BatchMode=yes "$host" "echo ok"; then
    err "Cannot reach ${host} via SSH"
    info "Ensure 'ssh ${host}' works with key auth (no password)"
    exit 1
  fi

  # 2. Sync repo to remote ~/aily
  local remote_dir="~/aily"
  if command -v rsync >/dev/null 2>&1; then
    ui_spin "Syncing aily to ${host}:${remote_dir}" \
      rsync -az --exclude '.env' --exclude '__pycache__' --exclude '.git' \
      "${SCRIPT_DIR}/" "${host}:${remote_dir}/"
  else
    ui_spin "Copying aily to ${host}:${remote_dir}" \
      scp -rq "${SCRIPT_DIR}" "${host}:${remote_dir}"
  fi

  # 3. Copy config
  ui_spin "Copying config to ${host}" \
    ssh -o BatchMode=yes "$host" "mkdir -p ~/.config/aily && chmod 700 ~/.config/aily"
  scp -q "${ENV_FILE}" "${host}:~/.config/aily/env"
  ssh -o BatchMode=yes "$host" "chmod 600 ~/.config/aily/env"
  ok "Config copied"

  # 4. Run init on remote
  printf "\n"
  info "Running init on ${host}..."
  ssh -o BatchMode=yes "$host" "cd ${remote_dir} && ./aily init --non-interactive"
  echo ""
  ok "Deployed to ${host}"

  # 5. Auto-add to SSH_HOSTS if not already listed
  local current_hosts
  current_hosts=$(env_get "SSH_HOSTS" "localhost")
  if [[ ",$current_hosts," != *",$host,"* ]]; then
    env_set "SSH_HOSTS" "${current_hosts},${host}"
    ok "Added ${host} to SSH_HOSTS"
  fi

  echo ""
  info "Verify: aily status"
}

# -------------------------------------------------------------------
# aily uninstall
# -------------------------------------------------------------------
cmd_uninstall() {
  hdr "aily uninstall"
  echo ""

  # Confirm
  printf "  This will remove aily hook symlinks and agent configurations.\n"
  printf "  Your credentials file will also be deleted.\n"
  echo ""
  printf "  ${C_BOLD}Continue? (y/N):${C_RESET} "
  local answer
  read -r answer
  case "$answer" in
    [Yy]|[Yy][Ee][Ss]) ;;
    *)
      echo "  Aborted."
      exit 0
      ;;
  esac
  echo ""

  # 1. Remove hook symlinks
  printf "  ${C_BOLD}Removing hook symlinks${C_RESET}\n"
  local hook_files
  hook_files=$(find "$HOOKS_DIR" -maxdepth 1 -type l 2>/dev/null || true)
  if [[ -n "$hook_files" ]]; then
    while IFS= read -r link; do
      local link_target
      link_target=$(readlink "$link" 2>/dev/null || echo "")
      # Only remove symlinks pointing to our hooks directory
      if [[ "$link_target" == *"/hooks/"* ]]; then
        rm -f "$link"
        ok "Removed $(basename "$link")"
      fi
    done <<< "$hook_files"
  else
    info "No hook symlinks found"
  fi

  # 2. Remove from Claude Code settings.json
  printf "\n  ${C_BOLD}Cleaning agent configurations${C_RESET}\n"
  local claude_settings="$HOME/.claude/settings.json"
  if [[ -f "$claude_settings" ]] && grep -q "notify-clawdia\|notify-claude" "$claude_settings" 2>/dev/null; then
    warn "Claude Code: Remove the aily hook from ${claude_settings} manually"
  else
    info "Claude Code: no aily hook found"
  fi

  # Codex config.toml
  local codex_config="$HOME/.codex/config.toml"
  if [[ -f "$codex_config" ]] && grep -q "notify-codex" "$codex_config" 2>/dev/null; then
    # Remove the notify line
    python3 -c "
import re, sys
path = sys.argv[1]
with open(path) as f:
    text = f.read()
text = re.sub(r'^notify\s*=.*notify-codex.*\n?', '', text, flags=re.MULTILINE)
with open(path, 'w') as f:
    f.write(text)
" "$codex_config" 2>/dev/null && ok "Codex CLI: removed notify hook" || warn "Codex CLI: failed to update config"
  else
    info "Codex CLI: no aily hook found"
  fi

  # Gemini settings.json
  local gemini_settings="$HOME/.gemini/settings.json"
  if [[ -f "$gemini_settings" ]] && grep -q "notify-gemini" "$gemini_settings" 2>/dev/null; then
    python3 -c "
import json, sys
path = sys.argv[1]
with open(path) as f:
    settings = json.load(f)
hooks = settings.get('hooks', {})
after_agent = hooks.get('AfterAgent', [])
if isinstance(after_agent, list):
    new_groups = []
    for group in after_agent:
        if isinstance(group, dict):
            group_hooks = group.get('hooks', [])
            group_hooks = [h for h in group_hooks
                          if not (isinstance(h, dict) and
                                  (h.get('name') == 'discord-notify' or
                                   str(h.get('command', '')).endswith('notify-gemini.sh')))]
            if group_hooks:
                group['hooks'] = group_hooks
                new_groups.append(group)
        else:
            new_groups.append(group)
    hooks['AfterAgent'] = new_groups
    settings['hooks'] = hooks
with open(path, 'w') as f:
    json.dump(settings, f, indent=2)
    f.write('\n')
" "$gemini_settings" 2>/dev/null && ok "Gemini CLI: removed notify hook" || warn "Gemini CLI: failed to update config"
  else
    info "Gemini CLI: no aily hook found"
  fi

  # OpenCode plugins
  local opencode_plugins="$HOME/.config/opencode/plugins"
  if [[ -d "$opencode_plugins" ]]; then
    local oc_found=false
    for f in "$opencode_plugins"/aily-notify* "$opencode_plugins"/notify-opencode*; do
      if [[ -e "$f" ]]; then
        rm -f "$f" && ok "OpenCode: removed $(basename "$f")" || warn "OpenCode: failed to remove $(basename "$f")"
        oc_found=true
      fi
    done
    if [[ "$oc_found" == "false" ]]; then
      info "OpenCode: no aily plugin found"
    fi
  else
    info "OpenCode: plugins dir not found"
  fi

  # 3. Remove tmux hooks
  printf "\n  ${C_BOLD}Removing tmux hooks${C_RESET}\n"
  if command -v tmux >/dev/null 2>&1 && tmux list-sessions >/dev/null 2>&1; then
    tmux set-hook -gu session-created 2>/dev/null && ok "Removed session-created hook" || info "No session-created hook"
    tmux set-hook -gu session-closed 2>/dev/null && ok "Removed session-closed hook" || info "No session-closed hook"
  else
    info "tmux not running"
  fi

  # 4. Remove CLI symlink
  printf "\n  ${C_BOLD}Removing CLI symlink${C_RESET}\n"
  local aily_link="$HOME/.local/bin/aily"
  if [[ -L "$aily_link" ]]; then
    rm -f "$aily_link"
    ok "Removed ${aily_link}"
  else
    info "No CLI symlink found"
  fi

  # 5. Remove credentials file
  printf "\n  ${C_BOLD}Removing credentials${C_RESET}\n"
  if [[ -f "$ENV_FILE" ]]; then
    rm -f "$ENV_FILE"
    ok "Removed ${ENV_FILE}"
  else
    info "No credentials file found"
  fi
  # Clean up config dir if empty
  local config_dir
  config_dir="$(dirname "$ENV_FILE")"
  rmdir "$config_dir" 2>/dev/null && ok "Removed ${config_dir}" || true

  echo ""
  ok "Uninstall complete"
  info "To re-install, run: ./aily init (from the repo directory)"
  echo ""
}

# -------------------------------------------------------------------
# aily help / version
# -------------------------------------------------------------------
cmd_help() {
  printf "${C_BOLD}aily${C_RESET} %s -- AI agent notification relay\n" "${AILY_VERSION:-dev}"
  echo ""
  printf "${C_BOLD}Usage:${C_RESET}\n"
  echo "  aily [--json] [--verbose] <command> [options]"
  echo ""
  printf "${C_BOLD}Setup & diagnostics:${C_RESET}\n"
  echo "  init                      Interactive setup wizard"
  echo "    --non-interactive         Read from env vars instead of prompting"
  echo "  status                    Show configuration and connectivity"
  echo "  doctor                    Diagnose common issues"
  echo "  deploy <host>             Deploy aily to a remote host via SSH"
  echo "  uninstall                 Remove hooks and agent configurations"
  echo ""
  printf "${C_BOLD}Dashboard:${C_RESET}\n"
  echo "  sessions                  List active sessions from dashboard"
  echo "    --json                    Output raw JSON"
  echo "    --ssh                     List via SSH instead of dashboard API"
  echo "  sync [session-name]       Trigger message sync for a session"
  echo "  logs [session-name]       Fetch recent messages for a session"
  echo "  tail [session-name]       Alias for logs"
  echo "  export [session-name]     Export a session to markdown or json"
  echo "    --json                    Output raw JSON"
  echo "    -n, --limit N             Number of messages (default: 20)"
  echo "  attach [session-name]     Attach to an active tmux session"
  echo ""
  printf "${C_BOLD}Configuration:${C_RESET}\n"
  echo "  config show               Show current config (tokens redacted)"
  echo "  config set KEY VALUE      Update a config key"
  echo "  config dashboard-url URL  Shortcut: set dashboard URL"
  echo ""
  printf "${C_BOLD}Usage monitoring:${C_RESET}\n"
  echo "  usage                     Show current API rate limit status"
  echo "    --json                    Output raw JSON"
  echo "  usage queue               Show pending command queue"
  echo "  usage queue add S CMD     Queue a command for session S"
  echo "  usage queue execute       Manually execute all pending commands"
  echo ""
  printf "${C_BOLD}Thread management:${C_RESET}\n"
  echo "  start [name]              Create thread (default: current tmux session)"
  echo "  stop [name]               Archive thread (default: current tmux session)"
  echo "  auto [on|off]             Toggle auto thread sync (or show status)"
  echo ""
  printf "${C_BOLD}General:${C_RESET}\n"
  echo "  help, -h, --help          Show this help"
  echo "  version, -v, --version    Show version"
  echo ""
  echo "Config file: ${ENV_FILE}"
  echo "Dashboard:   $(dashboard_url)"
  echo ""
}

cmd_version() {
  printf "aily %s\n" "${AILY_VERSION:-dev}"
}

# ===================================================================
# MAIN
# ===================================================================

# Parse global flags.
while [[ "${1:-}" == --* ]]; do
  case "$1" in
    --json) AILY_JSON=true; shift ;;
    --verbose) set -x; shift ;;
    --help) cmd_help; exit 0 ;;
    *) break ;;
  esac
done

CMD="${1:-help}"
shift 2>/dev/null || true

case "$CMD" in
  init)       cmd_init "$@" ;;
  status)     cmd_status "$@" ;;
  sessions)   cmd_sessions "$@" ;;
  sync)       cmd_sync "$@" ;;
  logs)       cmd_logs "$@" ;;
  tail)       cmd_logs "$@" ;;
  attach)     cmd_attach "$@" ;;
  export)     cmd_export "$@" ;;
  config)     cmd_config "$@" ;;
  doctor)     cmd_doctor "$@" ;;
  start)      cmd_start "$@" ;;
  stop)       cmd_stop "$@" ;;
  auto)       cmd_auto "$@" ;;
  usage)      cmd_usage "$@" ;;
  deploy)     cmd_deploy "$@" ;;
  uninstall)  cmd_uninstall "$@" ;;
  help|-h|--help) cmd_help ;;
  version|-v|--version) cmd_version ;;
  *)
    err "Unknown command: ${CMD}"
    echo ""
    cmd_help
    exit 1
    ;;
esac
