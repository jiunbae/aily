#!/bin/bash
# aily -- CLI for managing AI agent notification relay.
# Single self-contained tool: setup wizard, diagnostics, dashboard API,
# thread management, and platform configuration.
#
# Usage:
#   aily init              Interactive setup wizard
#   aily status            Show configuration and connectivity status
#   aily sessions          List active sessions from dashboard
#   aily sync [name]       Trigger message sync for a session
#   aily logs [name]       Fetch recent messages for a session
#   aily attach [name]     Attach to a tmux session
#   aily export <name>     Export session messages
#   aily config ...        Show/edit configuration
#   aily doctor            Diagnose common issues
#   aily start [name]      Create thread for tmux session
#   aily stop [name]       Archive thread for tmux session
#   aily auto [on|off]     Toggle auto thread sync
#   aily uninstall         Remove aily hooks and configuration
#   aily help              Show this help

set -euo pipefail

# ---------------------------------------------------------------------------
# Paths
# ---------------------------------------------------------------------------
_self="$0"
# Resolve symlinks to find the actual repo directory
if [[ -L "$_self" ]]; then
  _self="$(readlink "$_self")"
  # Handle relative symlinks
  [[ "$_self" != /* ]] && _self="$(cd "$(dirname "$0")" && cd "$(dirname "$_self")" && pwd)/$(basename "$_self")"
fi
SCRIPT_DIR="$(cd "$(dirname "$_self")" && pwd)"
_AILY_CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/aily"
if [[ -n "${AILY_ENV:-}" ]]; then
  ENV_FILE="$AILY_ENV"
else
  ENV_FILE="$_AILY_CONFIG_DIR/env"
fi
HOOKS_DIR="$HOME/.claude/hooks"
AILY_VERSION="2026.2.18"
AILY_JSON=false

# ---------------------------------------------------------------------------
# Colors & formatting
# ---------------------------------------------------------------------------
if [[ -t 1 ]]; then
  C_RESET=$'\033[0m'
  C_BOLD=$'\033[1m'
  C_DIM=$'\033[2m'
  C_RED=$'\033[31m'
  C_GREEN=$'\033[32m'
  C_YELLOW=$'\033[33m'
  C_BLUE=$'\033[34m'
  C_CYAN=$'\033[36m'
  C_MAGENTA=$'\033[35m'
else
  C_RESET="" C_BOLD="" C_DIM="" C_RED="" C_GREEN=""
  C_YELLOW="" C_BLUE="" C_CYAN="" C_MAGENTA=""
fi

ok()   { printf "  ${C_GREEN}‚úì${C_RESET} %s\n" "$*"; }
warn() { printf "  ${C_YELLOW}‚ö†Ô∏è${C_RESET}  %s\n" "$*"; }
err()  { printf "  ${C_RED}‚úó${C_RESET} %s\n" "$*" >&2; }
info() { printf "  ${C_DIM}¬∑${C_RESET} %s\n" "$*"; }
hdr()  { printf "\n${C_BOLD}=== %s ===${C_RESET}\n" "$*"; }

# Box-drawing helpers (rounded corners, dimmed frame)
BOX_W=46

_repeat() { local s=""; for ((i=0; i<$1; i++)); do s+="$2"; done; echo -n "$s"; }

box_top() {
  local title="$1"
  local fill=$((BOX_W - ${#title} - 3))
  printf "  ${C_DIM}‚ï≠‚îÄ${C_RESET} ${C_BOLD}%s${C_RESET} ${C_DIM}%s‚ïÆ${C_RESET}\n" "$title" "$(_repeat $fill '‚îÄ')"
}
box_bottom() {
  local label="${1:-}"
  if [[ -n "$label" ]]; then
    local fill=$((BOX_W - ${#label} - 3))
    printf "  ${C_DIM}‚ï∞‚îÄ${C_RESET} %s ${C_DIM}%s‚ïØ${C_RESET}\n" "$label" "$(_repeat $fill '‚îÄ')"
  else
    printf "  ${C_DIM}‚ï∞%s‚ïØ${C_RESET}\n" "$(_repeat $((BOX_W)) '‚îÄ')"
  fi
}
box_sep() { printf "  ${C_DIM}‚îú%s‚î§${C_RESET}\n" "$(_repeat $BOX_W '‚îÄ')"; }
box_line() {
  local content="$1"
  # Strip ANSI to measure visible width
  local vis
  vis=$(printf '%s' "$content" | sed $'s/\033\\[[0-9;]*m//g')
  local vis_len=${#vis}
  local inner=$((BOX_W - 2))
  local pad=$((inner - vis_len))
  [[ $pad -lt 0 ]] && pad=0
  printf "  ${C_DIM}‚îÇ${C_RESET} %s%s ${C_DIM}‚îÇ${C_RESET}\n" "$content" "$(_repeat $pad ' ')"
}
box_empty() { printf "  ${C_DIM}‚îÇ${C_RESET} %$((BOX_W - 2))s ${C_DIM}‚îÇ${C_RESET}\n" ""; }

_progress_bar() {
  local count=$1 total=$2 width=${3:-16}
  local filled=0
  if [[ $total -gt 0 ]]; then
    filled=$(( (count * width) / total ))
  fi
  local empty=$((width - filled))
  printf '%s%s' "$(_repeat $filled '‚ñà')" "$(_repeat $empty '‚ñë')"
}

json_output() {
  # If --json flag is set, output JSON instead of formatted text.
  if [[ "$AILY_JSON" == true ]]; then
    printf '%s\n' "$1"
    return 0
  fi
  return 1
}

# ---------------------------------------------------------------------------
# Interactive UI toolkit (pure bash + ANSI)
# ---------------------------------------------------------------------------

# Cleanup state
_UI_CURSOR_HIDDEN=false
_UI_SPINNER_PID=""

_ui_cleanup() {
  if [[ "$_UI_CURSOR_HIDDEN" == true ]]; then
    printf '\033[?25h' >&2
    _UI_CURSOR_HIDDEN=false
  fi
  if [[ -n "$_UI_SPINNER_PID" ]] && kill -0 "$_UI_SPINNER_PID" 2>/dev/null; then
    kill "$_UI_SPINNER_PID" 2>/dev/null
    wait "$_UI_SPINNER_PID" 2>/dev/null || true
    _UI_SPINNER_PID=""
  fi
}
trap '_ui_cleanup' EXIT
trap '_ui_cleanup; exit 130' INT
trap '_ui_cleanup; exit 143' TERM

ui_spin() {
  # Usage: ui_spin "label" command [args...]
  # Animated braille spinner while command runs. Returns command exit code.
  local _label="$1"; shift

  # Non-TTY fallback
  if [[ ! -t 2 ]]; then
    printf "  %s... " "$_label" >&2
    local _rc=0
    "$@" >/dev/null 2>&1 || _rc=$?
    if [[ $_rc -eq 0 ]]; then
      printf "OK\n" >&2
    else
      printf "FAILED\n" >&2
    fi
    return $_rc
  fi

  local _frames="‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚†á‚†è"
  local _nframes=10

  printf '\033[?25l' >&2
  _UI_CURSOR_HIDDEN=true

  "$@" >/dev/null 2>&1 &
  _UI_SPINNER_PID=$!

  local _i=0
  while kill -0 "$_UI_SPINNER_PID" 2>/dev/null; do
    local _f="${_frames:$(( _i % _nframes )):1}"
    printf '\r\033[2K  %b%s%b %s' "$C_CYAN" "$_f" "$C_RESET" "$_label" >&2
    sleep 0.08
    _i=$(( _i + 1 ))
  done

  set +e
  wait "$_UI_SPINNER_PID" 2>/dev/null
  local _rc=$?
  set -e
  _UI_SPINNER_PID=""

  if [[ $_rc -eq 0 ]]; then
    printf '\r\033[2K  %b‚úì%b %s\n' "$C_GREEN" "$C_RESET" "$_label" >&2
  else
    printf '\r\033[2K  %b‚úó%b %s\n' "$C_RED" "$C_RESET" "$_label" >&2
  fi

  printf '\033[?25h' >&2
  _UI_CURSOR_HIDDEN=false
  return $_rc
}

ui_select() {
  # Usage: ui_select <var_name> <label> <opt1> <opt2> ... [-- <desc1> <desc2> ...]
  # Arrow-key / j,k navigation. Sets var to 0-based index.
  local _var="$1" _label="$2"; shift 2

  local _opts=() _descs=() _in_opts=true
  while [[ $# -gt 0 ]]; do
    if [[ "$1" == "--" ]]; then
      _in_opts=false; shift; continue
    fi
    if [[ "$_in_opts" == true ]]; then
      _opts[${#_opts[@]}]="$1"
    else
      _descs[${#_descs[@]}]="$1"
    fi
    shift
  done

  local _n=${#_opts[@]}
  local _sel=0

  # Non-TTY fallback: numbered list
  if [[ ! -t 0 ]]; then
    printf "  %s\n" "$_label" >&2
    local _i
    for (( _i=0; _i<_n; _i++ )); do
      local _d=""
      [[ ${#_descs[@]} -gt $_i ]] && _d="  (${_descs[$_i]})"
      printf "    %d) %s%s\n" "$((_i+1))" "${_opts[$_i]}" "$_d" >&2
    done
    local _choice
    read -rp "  Choice [1]: " _choice 2>&1
    _choice="${_choice:-1}"
    eval "$_var=$(( _choice - 1 ))"
    return
  fi

  printf '\033[?25l' >&2
  _UI_CURSOR_HIDDEN=true

  # Print label with hint
  printf "  %b%s%b  %b(‚Üë‚Üì/jk to move, enter to select)%b\n" \
    "$C_BOLD" "$_label" "$C_RESET" "$C_DIM" "$C_RESET" >&2

  # Render options
  _ui_sel_draw() {
    local _i
    for (( _i=0; _i<_n; _i++ )); do
      printf '\033[2K' >&2
      local _d=""
      [[ ${#_descs[@]} -gt $_i ]] && _d="  ${C_DIM}${_descs[$_i]}${C_RESET}"
      if [[ $_i -eq $_sel ]]; then
        printf "    %b>%b %b%s%b%b\n" "$C_CYAN" "$C_RESET" "$C_BOLD" "${_opts[$_i]}" "$C_RESET" "$_d" >&2
      else
        printf "      %s%b\n" "${_opts[$_i]}" "$_d" >&2
      fi
    done
  }
  _ui_sel_draw

  while true; do
    local _key=""
    IFS= read -rsn1 _key

    if [[ "$_key" == $'\033' ]]; then
      local _seq=""
      read -rsn2 -t 1 _seq || true
      case "$_seq" in
        '[A') [[ $_sel -gt 0 ]] && _sel=$(( _sel - 1 )) ;;
        '[B') [[ $_sel -lt $(( _n - 1 )) ]] && _sel=$(( _sel + 1 )) ;;
      esac
    elif [[ "$_key" == "k" ]]; then
      [[ $_sel -gt 0 ]] && _sel=$(( _sel - 1 ))
    elif [[ "$_key" == "j" ]]; then
      [[ $_sel -lt $(( _n - 1 )) ]] && _sel=$(( _sel + 1 ))
    elif [[ "$_key" == "" ]]; then
      break
    fi

    # Move up _n lines and redraw
    printf "\033[${_n}A" >&2
    _ui_sel_draw
  done

  printf '\033[?25h' >&2
  _UI_CURSOR_HIDDEN=false

  eval "$_var=$_sel"
}

ui_confirm() {
  # Usage: ui_confirm "label" [default: y|n]
  # Returns 0 for yes, 1 for no.
  local _label="$1" _default="${2:-y}"

  if [[ ! -t 0 ]]; then
    [[ "$_default" == "y" ]] && return 0 || return 1
  fi

  local _hint
  if [[ "$_default" == "y" ]]; then
    _hint="${C_BOLD}Y${C_RESET}${C_DIM}/n${C_RESET}"
  else
    _hint="${C_DIM}y/${C_RESET}${C_BOLD}N${C_RESET}"
  fi
  local _answer
  printf "  %s [%b]: " "$_label" "$_hint" >&2
  read -rn1 _answer </dev/tty
  echo "" >&2
  _answer="${_answer:-$_default}"
  case "$_answer" in
    [Yy]) return 0 ;;
    *)    return 1 ;;
  esac
}

# ---------------------------------------------------------------------------
# Dependency check
# ---------------------------------------------------------------------------
require_cmd() {
  local cmd="$1" hint="${2:-}"
  if ! command -v "$cmd" >/dev/null 2>&1; then
    err "$cmd not found${hint:+ ($hint)}"
    return 1
  fi
  return 0
}

require_deps() {
  local missing=0
  require_cmd curl   "install via your package manager" || missing=1
  require_cmd jq     "install via: brew install jq / apt install jq" || missing=1
  if [[ $missing -ne 0 ]]; then
    echo "" >&2
    err "Missing required dependencies. Install them and retry."
    exit 1
  fi
}

# ---------------------------------------------------------------------------
# Config helpers
# ---------------------------------------------------------------------------
env_get() {
  local key="$1" default="${2:-}"
  if [[ -f "$ENV_FILE" ]]; then
    local val
    val=$(grep -E "^${key}=" "$ENV_FILE" 2>/dev/null | tail -1 | cut -d= -f2- | tr -d '"' | tr -d "'")
    echo "${val:-$default}"
  else
    echo "$default"
  fi
}

env_set() {
  local key="$1" value="$2"
  if [[ ! -f "$ENV_FILE" ]]; then
    mkdir -p "$(dirname "$ENV_FILE")"
    touch "$ENV_FILE"
    chmod 600 "$ENV_FILE"
  fi
  if grep -qE "^${key}=" "$ENV_FILE" 2>/dev/null; then
    # Use python3 for safe in-place edit (matches install.sh style)
    python3 -c "
import re, sys
path = sys.argv[1]
key, val = sys.argv[2], sys.argv[3]
with open(path) as f:
    text = f.read()
text = re.sub(rf'^{key}=.*$', f'{key}=\"{val}\"', text, flags=re.MULTILINE)
with open(path, 'w') as f:
    f.write(text)
" "$ENV_FILE" "$key" "$value"
  else
    # Append with a blank separator if the file doesn't end with a newline
    if [[ -s "$ENV_FILE" ]] && [[ "$(tail -c1 "$ENV_FILE")" != "" ]]; then
      echo "" >> "$ENV_FILE"
    fi
    echo "${key}=\"${value}\"" >> "$ENV_FILE"
  fi
}

load_env() {
  if [[ -f "$ENV_FILE" ]]; then
    # shellcheck source=/dev/null
    source "$ENV_FILE"
  fi
}

redact() {
  local val="$1" show="${2:-4}"
  if [[ ${#val} -le $((show + 4)) ]]; then
    echo "****"
  else
    echo "${val:0:$show}...${val: -4}"
  fi
}

_generate_token() {
  if command -v openssl >/dev/null 2>&1; then
    openssl rand -hex 32
  elif command -v python3 >/dev/null 2>&1; then
    python3 -c "import secrets; print(secrets.token_hex(32))"
  else
    LC_ALL=C tr -dc 'a-f0-9' < /dev/urandom | head -c 64
    echo ""
  fi
}

# ---------------------------------------------------------------------------
# Dashboard API helpers
# ---------------------------------------------------------------------------
dashboard_url() {
  env_get "AILY_DASHBOARD_URL" "http://localhost:8080"
}

dashboard_token() {
  env_get "AILY_AUTH_TOKEN" ""
}

api_call() {
  local method="$1" path="$2"
  shift 2
  local url
  url="$(dashboard_url)${path}"
  local token
  token="$(dashboard_token)"

  local auth_header=""
  if [[ -n "$token" ]]; then
    auth_header="Authorization: Bearer ${token}"
  fi

  if [[ "$method" == "GET" ]]; then
    if [[ -n "$auth_header" ]]; then
      curl -sf -H "$auth_header" -H "Content-Type: application/json" "$url" "$@" 2>/dev/null
    else
      curl -sf -H "Content-Type: application/json" "$url" "$@" 2>/dev/null
    fi
  else
    if [[ -n "$auth_header" ]]; then
      curl -sf -X "$method" -H "$auth_header" -H "Content-Type: application/json" "$url" "$@" 2>/dev/null
    else
      curl -sf -X "$method" -H "Content-Type: application/json" "$url" "$@" 2>/dev/null
    fi
  fi
}

# ---------------------------------------------------------------------------
# tmux helpers
# ---------------------------------------------------------------------------
detect_tmux_session() {
  local TMUX_BIN="/opt/homebrew/bin/tmux"
  if [[ ! -x "$TMUX_BIN" ]]; then
    TMUX_BIN="tmux"
  fi

  if [[ -n "${TMUX_PANE:-}" ]]; then
    "$TMUX_BIN" display-message -t "${TMUX_PANE}" -p '#{session_name}' 2>/dev/null || true
  elif [[ -n "${TMUX:-}" ]]; then
    "$TMUX_BIN" display-message -p '#S' 2>/dev/null || true
  fi
}

format_thread_name() {
  local session="$1" host="$2"
  local _default='[agent] {session} - {host}'
  local fmt="${THREAD_NAME_FORMAT:-$_default}"
  fmt="${fmt//\{session\}/$session}"
  fmt="${fmt//\{host\}/$host}"
  echo "$fmt"
}

# ---------------------------------------------------------------------------
# Platform loaders (sourced from hooks dir)
# ---------------------------------------------------------------------------
load_discord_env() {
  if [[ ! -f "$ENV_FILE" ]]; then return 1; fi
  # shellcheck source=/dev/null
  source "$ENV_FILE"
  if [[ -z "${DISCORD_BOT_TOKEN:-}" || -z "${DISCORD_CHANNEL_ID:-}" ]]; then return 1; fi
  local lib="${HOOKS_DIR}/discord-lib.sh"
  if [[ ! -f "$lib" ]]; then return 1; fi
  # shellcheck source=/dev/null
  source "$lib"
  return 0
}

load_slack_env() {
  if [[ ! -f "$ENV_FILE" ]]; then return 1; fi
  # shellcheck source=/dev/null
  source "$ENV_FILE"
  if [[ -z "${SLACK_BOT_TOKEN:-}" || -z "${SLACK_CHANNEL_ID:-}" ]]; then return 1; fi
  local lib="${HOOKS_DIR}/slack-lib.sh"
  if [[ ! -f "$lib" ]]; then return 1; fi
  # shellcheck source=/dev/null
  source "$lib"
  return 0
}

# ---------------------------------------------------------------------------
# Prompt helpers (for init wizard)
# ---------------------------------------------------------------------------
prompt_value() {
  local label="$1" default="${2:-}" secret="${3:-false}"
  local value prompt
  prompt="  ${label}"
  if [[ -n "$default" ]]; then
    if [[ "$secret" == "true" ]]; then
      prompt+=" ${C_DIM}[$(redact "$default")]${C_RESET}"
    else
      prompt+=" ${C_DIM}[${default}]${C_RESET}"
    fi
  fi
  prompt+=": "

  if [[ "$secret" == "true" ]]; then
    printf '%s%s ' "$prompt" "${C_DIM}(input is hidden)${C_RESET}" >&2
    read -rs value
    if [[ -n "$value" ]]; then
      printf '‚úì\n' >&2
    else
      echo "" >&2
    fi
  else
    read -rp "$prompt" value
  fi
  echo "${value:-$default}"
}

prompt_yn() {
  local label="$1" default="${2:-y}"
  local hint="Y/n"
  if [[ "$default" == "n" ]]; then
    hint="y/N"
  fi
  local answer
  read -rp "  ${label} (${hint}): " answer
  answer="${answer:-$default}"
  case "$answer" in
    [Yy]|[Yy][Ee][Ss]) return 0 ;;
    *)                 return 1 ;;
  esac
}

# ===================================================================
# COMMANDS
# ===================================================================

# -------------------------------------------------------------------
# aily init
# -------------------------------------------------------------------
cmd_init() {
  local non_interactive=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --non-interactive) non_interactive=true; shift ;;
      *) shift ;;
    esac
  done

  require_deps

  hdr "aily setup wizard"
  echo ""

  # -- 1. Platform setup (required) --
  # Pre-load existing config so unselected platforms are preserved
  local discord_token="" discord_channel=""
  local slack_token="" slack_app_token="" slack_channel=""
  if [[ -f "$ENV_FILE" ]]; then
    discord_token="$(env_get DISCORD_BOT_TOKEN "")"
    discord_channel="$(env_get DISCORD_CHANNEL_ID "")"
    slack_token="$(env_get SLACK_BOT_TOKEN "")"
    slack_app_token="$(env_get SLACK_APP_TOKEN "")"
    slack_channel="$(env_get SLACK_CHANNEL_ID "")"
  fi

  if [[ "$non_interactive" == "true" ]]; then
    discord_token="${DISCORD_BOT_TOKEN:-$(env_get DISCORD_BOT_TOKEN "")}"
    discord_channel="${DISCORD_CHANNEL_ID:-$(env_get DISCORD_CHANNEL_ID "")}"
    slack_token="${SLACK_BOT_TOKEN:-$(env_get SLACK_BOT_TOKEN "")}"
    slack_app_token="${SLACK_APP_TOKEN:-$(env_get SLACK_APP_TOKEN "")}"
    slack_channel="${SLACK_CHANNEL_ID:-$(env_get SLACK_CHANNEL_ID "")}"
  else
    # Determine default based on existing config
    local _plat_default=0
    if [[ -n "$(env_get DISCORD_BOT_TOKEN "")" && -n "$(env_get SLACK_BOT_TOKEN "")" ]]; then
      _plat_default=2
    elif [[ -n "$(env_get SLACK_BOT_TOKEN "")" ]]; then
      _plat_default=1
    fi

    local platform_idx="$_plat_default"
    ui_select platform_idx "Notification platform" \
      "discord" "slack" "both" \
      -- "Discord bot" "Slack bot" "Discord + Slack"

    # Discord tokens
    if [[ "$platform_idx" == 0 || "$platform_idx" == 2 ]]; then
      # Show setup guide if no existing token
      if [[ -z "$(env_get DISCORD_BOT_TOKEN "")" ]]; then
        if ! prompt_yn "Do you already have a Discord bot?" "n"; then
          echo ""
          printf "  ${C_BOLD}How to create a Discord bot:${C_RESET}\n"
          echo ""
          printf "  ${C_BOLD}1.${C_RESET} Go to ${C_CYAN}https://discord.com/developers/applications${C_RESET}\n"
          printf "  ${C_BOLD}2.${C_RESET} Click ${C_BOLD}New Application${C_RESET} ‚Üí name it (e.g. \"aily\") ‚Üí Create\n"
          printf "  ${C_BOLD}3.${C_RESET} Go to ${C_BOLD}Bot${C_RESET} tab:\n"
          printf "       ‚Ä¢ Click ${C_BOLD}Reset Token${C_RESET} ‚Üí copy the token\n"
          printf "       ‚Ä¢ Enable ${C_BOLD}Message Content Intent${C_RESET} (under Privileged Intents)\n"
          printf "  ${C_BOLD}4.${C_RESET} Go to ${C_BOLD}OAuth2 ‚Üí URL Generator${C_RESET}:\n"
          printf "       ‚Ä¢ Scopes: ${C_BOLD}bot${C_RESET}\n"
          printf "       ‚Ä¢ Permissions: ${C_BOLD}Send Messages${C_RESET}, ${C_BOLD}Create Public Threads${C_RESET},\n"
          printf "         ${C_BOLD}Send Messages in Threads${C_RESET}, ${C_BOLD}Manage Threads${C_RESET}, ${C_BOLD}Read Message History${C_RESET}\n"
          printf "       ‚Ä¢ Copy the URL ‚Üí open in browser ‚Üí add bot to your server\n"
          printf "  ${C_BOLD}5.${C_RESET} Get channel ID: ${C_BOLD}Settings ‚Üí Advanced ‚Üí Developer Mode${C_RESET} ON,\n"
          printf "       then right-click the channel ‚Üí ${C_BOLD}Copy Channel ID${C_RESET}\n"
          echo ""
        fi
      fi
      discord_token=$(prompt_value "Discord bot token" "$(env_get DISCORD_BOT_TOKEN "")" true)
      discord_channel=$(prompt_value "Discord channel ID" "$(env_get DISCORD_CHANNEL_ID "")")

      if [[ -n "$discord_token" && -n "$discord_channel" ]]; then
        local discord_resp=""
        discord_resp=$(curl -sf -H "Authorization: Bot ${discord_token}" \
          "https://discord.com/api/v10/channels/${discord_channel}" 2>/dev/null || echo "")
        if [[ -n "$discord_resp" ]] && echo "$discord_resp" | jq -e '.id' >/dev/null 2>&1; then
          local chan_name
          chan_name=$(echo "$discord_resp" | jq -r '.name // "unknown"')
          ok "Discord: ${chan_name}"
          _check_discord_permissions "${discord_token}" "${discord_channel}" "      " || \
            warn "Missing permissions ‚Äî update at https://discord.com/developers/applications"
        else
          warn "Could not validate Discord credentials"
        fi
      fi
      echo ""
    fi

    # Slack tokens
    if [[ "$platform_idx" == 1 || "$platform_idx" == 2 ]]; then
      # Show setup guide if no existing token
      if [[ -z "$(env_get SLACK_BOT_TOKEN "")" ]]; then
        if ! prompt_yn "Do you already have a Slack app?" "n"; then
          echo ""
          printf "  ${C_BOLD}How to create a Slack app:${C_RESET}\n"
          echo ""
          printf "  ${C_BOLD}1.${C_RESET} Go to ${C_CYAN}https://api.slack.com/apps${C_RESET} ‚Üí ${C_BOLD}Create New App${C_RESET}\n"
          printf "       ‚Ä¢ Choose ${C_BOLD}From scratch${C_RESET} ‚Üí name it ‚Üí select workspace\n"
          printf "  ${C_BOLD}2.${C_RESET} Go to ${C_BOLD}Socket Mode${C_RESET} ‚Üí enable it\n"
          printf "       ‚Ä¢ Generate an app token (name: \"aily\", scope: ${C_BOLD}connections:write${C_RESET})\n"
          printf "       ‚Ä¢ Copy the ${C_BOLD}xapp-...${C_RESET} token\n"
          printf "  ${C_BOLD}3.${C_RESET} Go to ${C_BOLD}OAuth & Permissions${C_RESET} ‚Üí add Bot Token Scopes:\n"
          printf "       ‚Ä¢ ${C_BOLD}chat:write${C_RESET}, ${C_BOLD}channels:history${C_RESET}, ${C_BOLD}channels:read${C_RESET}, ${C_BOLD}reactions:write${C_RESET}\n"
          printf "  ${C_BOLD}4.${C_RESET} Go to ${C_BOLD}Event Subscriptions${C_RESET} ‚Üí enable ‚Üí subscribe to:\n"
          printf "       ‚Ä¢ ${C_BOLD}message.channels${C_RESET}, ${C_BOLD}message.groups${C_RESET}\n"
          printf "  ${C_BOLD}5.${C_RESET} ${C_BOLD}Install App${C_RESET} to workspace ‚Üí copy the ${C_BOLD}xoxb-...${C_RESET} Bot Token\n"
          printf "  ${C_BOLD}6.${C_RESET} Get channel ID: right-click channel ‚Üí ${C_BOLD}View channel details${C_RESET}\n"
          printf "       ‚Üí Channel ID is at the bottom\n"
          echo ""
        fi
      fi
      slack_token=$(prompt_value "Slack bot token (xoxb-...)" "$(env_get SLACK_BOT_TOKEN "")" true)
      slack_app_token=$(prompt_value "Slack app token (xapp-...)" "$(env_get SLACK_APP_TOKEN "")" true)
      slack_channel=$(prompt_value "Slack channel ID" "$(env_get SLACK_CHANNEL_ID "")")

      if [[ -n "$slack_token" && -n "$slack_channel" ]]; then
        local slack_resp=""
        slack_resp=$(curl -sf -H "Authorization: Bearer ${slack_token}" \
          "https://slack.com/api/conversations.info?channel=${slack_channel}" 2>/dev/null || echo "")
        if [[ -n "$slack_resp" ]] && echo "$slack_resp" | jq -e '.ok == true' >/dev/null 2>&1; then
          local chan_name
          chan_name=$(echo "$slack_resp" | jq -r '.channel.name // "unknown"')
          ok "Slack: #${chan_name}"
          _check_slack_permissions "${slack_token}" "${slack_channel}" "      " || \
            warn "Missing scopes ‚Äî update at https://api.slack.com/apps"
        else
          warn "Could not validate Slack credentials"
        fi
      fi
      echo ""
    fi
  fi

  # -- 2. Quick-start defaults gate --
  local use_defaults=true
  local ssh_hosts="localhost"
  local thread_cleanup="archive"
  local new_session_agent="" claude_remote_control="false"
  local url="" token=""

  if [[ "$non_interactive" == "true" ]]; then
    ssh_hosts="${SSH_HOSTS:-$(env_get SSH_HOSTS "localhost")}"
    thread_cleanup="${THREAD_CLEANUP:-archive}"
    new_session_agent="${NEW_SESSION_AGENT:-$(env_get NEW_SESSION_AGENT "")}"
    claude_remote_control="${CLAUDE_REMOTE_CONTROL:-$(env_get CLAUDE_REMOTE_CONTROL "false")}"
    url="${AILY_DASHBOARD_URL:-$(env_get AILY_DASHBOARD_URL "")}"
    token="${AILY_AUTH_TOKEN:-$(env_get AILY_AUTH_TOKEN "")}"
    # Auto-generate token for localhost if not set
    if [[ -n "$url" && -z "$token" && ( "$url" == *"localhost"* || "$url" == *"127.0.0.1"* ) ]]; then
      token="$(_generate_token)"
    fi
  else
    info "Defaults: SSH=localhost, cleanup=archive, no agent, no dashboard"
    if ! ui_confirm "Use defaults?" "y"; then
      use_defaults=false
    fi
    echo ""
  fi

  # -- 3. SSH hosts (advanced) --
  if [[ "$use_defaults" == "false" ]]; then
    ssh_hosts=$(prompt_value "SSH hosts (comma-separated)" "$(env_get SSH_HOSTS "localhost")")

    if [[ -n "$ssh_hosts" && "$ssh_hosts" != "localhost" ]]; then
      IFS=',' read -ra host_list <<< "$ssh_hosts"
      for host in "${host_list[@]}"; do
        host=$(echo "$host" | tr -d ' ')
        ui_spin "Testing SSH to ${host}" ssh -o ConnectTimeout=3 -o BatchMode=yes "$host" "echo ok" || true
      done
    fi
    echo ""

    # -- 4. Thread cleanup (advanced) --
    local cleanup_idx=0
    ui_select cleanup_idx "Thread cleanup" \
      "archive" "delete" \
      -- "keeps history" "removes thread"
    case "$cleanup_idx" in
      1) thread_cleanup="delete" ;;
      *) thread_cleanup="archive" ;;
    esac
    ok "Thread cleanup: ${thread_cleanup}"
    echo ""

    # -- 5. Agent auto-launch (advanced) --
    local agent_idx=0
    ui_select agent_idx "Agent auto-launch on !new" \
      "none" "claude" "codex" "gemini" \
      -- "just create tmux session" "start Claude Code" "start Codex CLI" "start Gemini CLI"
    case "$agent_idx" in
      1) new_session_agent="claude" ;;
      2) new_session_agent="codex" ;;
      3) new_session_agent="gemini" ;;
      *) new_session_agent="" ;;
    esac

    if [[ "$new_session_agent" == "claude" ]]; then
      if ui_confirm "Enable remote-control mode for Claude?" "n"; then
        claude_remote_control="true"
      fi
    fi

    if [[ -n "$new_session_agent" ]]; then
      local rc_label=""
      [[ "$claude_remote_control" == "true" ]] && rc_label=" + remote-control"
      ok "Agent: ${new_session_agent}${rc_label}"
    else
      ok "Agent: none"
    fi
    echo ""

    # -- 6. Dashboard (optional) --
    if ui_confirm "Enable dashboard?" "n"; then
      url=$(prompt_value "Dashboard URL" "$(env_get AILY_DASHBOARD_URL "http://localhost:8080")")
      url="${url%/}"

      local _is_localhost=false
      [[ "$url" == *"localhost"* || "$url" == *"127.0.0.1"* ]] && _is_localhost=true

      # Determine auth token
      local existing_token
      existing_token="$(env_get AILY_AUTH_TOKEN "")"

      if [[ "$_is_localhost" == true ]]; then
        # Localhost: always auto-generate, never prompt
        token="${existing_token:-$(_generate_token)}"
        ok "Auth token: $(redact "$token")"

        if ui_spin "Testing dashboard" curl -sf --connect-timeout 3 "${url}/healthz"; then
          : # dashboard already running
        else
          if ui_confirm "Start local dashboard?" "y"; then
            _start_local_dashboard "$url" "$token"
            ui_spin "Checking dashboard" curl -sf --connect-timeout 5 "${url}/healthz" || \
              warn "Dashboard not responding ‚Äî will work on next start"
          fi
        fi
      else
        # Remote: prompt for token
        token=$(prompt_value "Auth token" "$existing_token" true)
        if ui_spin "Testing dashboard" curl -sf --connect-timeout 3 "${url}/healthz"; then
          if [[ -n "$token" ]]; then
            ui_spin "Validating token" curl -sf --connect-timeout 3 \
              -H "Authorization: Bearer ${token}" "${url}/api/stats" || \
              warn "Token validation failed"
          fi
        else
          warn "Dashboard not reachable ‚Äî continuing"
        fi
      fi
    fi
  fi
  echo ""

  # -- Write config --
  mkdir -p "$(dirname "$ENV_FILE")"

  local config_content=""
  config_content+="# aily configuration ‚Äî generated by aily init\n"
  config_content+="# $(date '+%Y-%m-%d %H:%M:%S')\n"
  config_content+="\n"
  config_content+="# --- Discord ---\n"
  if [[ -n "$discord_token" ]]; then
    config_content+="DISCORD_BOT_TOKEN=\"${discord_token}\"\n"
    config_content+="DISCORD_CHANNEL_ID=\"${discord_channel}\"\n"
  else
    config_content+="# DISCORD_BOT_TOKEN=\"\"\n"
    config_content+="# DISCORD_CHANNEL_ID=\"\"\n"
  fi
  config_content+="\n"
  config_content+="# --- Slack ---\n"
  if [[ -n "$slack_token" ]]; then
    config_content+="SLACK_BOT_TOKEN=\"${slack_token}\"\n"
    config_content+="SLACK_APP_TOKEN=\"${slack_app_token}\"\n"
    config_content+="SLACK_CHANNEL_ID=\"${slack_channel}\"\n"
  else
    config_content+="# SLACK_BOT_TOKEN=\"\"\n"
    config_content+="# SLACK_APP_TOKEN=\"\"\n"
    config_content+="# SLACK_CHANNEL_ID=\"\"\n"
  fi
  config_content+="\n"
  config_content+="# --- General ---\n"
  config_content+="SSH_HOSTS=\"${ssh_hosts}\"\n"
  config_content+="TMUX_THREAD_SYNC=\"true\"\n"
  config_content+="THREAD_CLEANUP=\"${thread_cleanup}\"\n"
  config_content+="\n"
  config_content+="# --- Agent Auto-Launch ---\n"
  if [[ -n "$new_session_agent" ]]; then
    config_content+="NEW_SESSION_AGENT=\"${new_session_agent}\"\n"
  else
    config_content+="# NEW_SESSION_AGENT=\"\"\n"
  fi
  if [[ "$claude_remote_control" == "true" ]]; then
    config_content+="CLAUDE_REMOTE_CONTROL=\"true\"\n"
  else
    config_content+="# CLAUDE_REMOTE_CONTROL=\"false\"\n"
  fi
  config_content+="\n"
  config_content+="# --- Dashboard (optional) ---\n"
  if [[ -n "$url" ]]; then
    config_content+="AILY_DASHBOARD_URL=\"${url}\"\n"
    [[ -n "$token" ]] && config_content+="AILY_AUTH_TOKEN=\"${token}\"\n"
  else
    config_content+="# AILY_DASHBOARD_URL=\"\"\n"
    config_content+="# AILY_AUTH_TOKEN=\"\"\n"
  fi

  printf '%b' "$config_content" > "$ENV_FILE"
  chmod 600 "$ENV_FILE"
  ok "Saved to ${ENV_FILE} (chmod 600)"
  echo ""

  # -- Install hooks --
  if [[ -x "${SCRIPT_DIR}/install.sh" ]]; then
    bash "${SCRIPT_DIR}/install.sh" 2>&1 | while IFS= read -r line; do
      echo "  $line"
    done
    # Verify critical hooks were installed
    local critical_hooks=(post.sh notify-claude.sh)
    local hooks_ok=true
    for hf in "${critical_hooks[@]}"; do
      if [[ ! -f "${HOOKS_DIR}/${hf}" && ! -L "${HOOKS_DIR}/${hf}" ]]; then
        hooks_ok=false
        break
      fi
    done
    if [[ "$hooks_ok" == "false" ]]; then
      warn "Hook symlinks may not have been created in ${HOOKS_DIR}/"
      info "This can happen if the directory is not writable"
      info "You can run hooks directly from: ${SCRIPT_DIR}/hooks/"
    fi
  else
    warn "install.sh not found at ${SCRIPT_DIR}/install.sh"
    info "Run install.sh manually to set up hooks"
  fi
  echo ""

  # -- Shell completions --
  local comp_dir
  if [[ -n "${ZSH_VERSION:-}" || "$SHELL" == */zsh ]]; then
    comp_dir="${ZDOTDIR:-$HOME}/.zfunc"
    mkdir -p "$comp_dir"
    if [[ -f "${SCRIPT_DIR}/completions/aily.zsh" ]]; then
      cp "${SCRIPT_DIR}/completions/aily.zsh" "${comp_dir}/_aily"
      ok "Zsh completions installed to ${comp_dir}/_aily"
      info "Add to .zshrc: fpath=(${comp_dir} \$fpath) && autoload -Uz compinit && compinit"
    else
      warn "Zsh completion script not found at ${SCRIPT_DIR}/completions/aily.zsh"
    fi
  else
    comp_dir="${BASH_COMPLETION_USER_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion/completions}"
    mkdir -p "$comp_dir"
    if [[ -f "${SCRIPT_DIR}/completions/aily.bash" ]]; then
      cp "${SCRIPT_DIR}/completions/aily.bash" "${comp_dir}/aily"
      ok "Bash completions installed to ${comp_dir}/aily"
    else
      warn "Bash completion script not found at ${SCRIPT_DIR}/completions/aily.bash"
    fi
  fi
  echo ""

  # -- Test notification --
  if [[ "$non_interactive" == "false" ]]; then
    if ui_confirm "Send a test notification?" "y"; then
      _send_test_notification
    else
      info "Skipped"
    fi
  else
    _send_test_notification
  fi

  # -- Start bridge bot --
  if [[ "$non_interactive" == "false" ]]; then
    echo ""
    if ui_confirm "Start Discord bridge bot? (enables !new, !kill, !sessions commands)" "y"; then
      cmd_bridge start
    else
      info "Skipped. Start later with: aily bridge start"
    fi
  fi

  echo ""
  hdr "Setup complete"
  echo ""
  info "Run 'aily status' to verify configuration"
  info "Run 'aily doctor' to diagnose issues"
  info "To add SSH hosts: aily config set SSH_HOSTS \"localhost,your-server\""
  echo ""
}

_start_local_dashboard() {
  local url="$1"
  local token="${2:-}"

  # Extract port from URL
  local port=8080
  if [[ "$url" =~ :([0-9]+) ]]; then
    port="${BASH_REMATCH[1]}"
  fi

  # Check if port is already in use
  if lsof -i ":${port}" >/dev/null 2>&1; then
    warn "Port ${port} is already in use"
    return 1
  fi

  # Detect available methods
  local _methods=() _descs=()
  if command -v uv >/dev/null 2>&1 && [[ -d "${SCRIPT_DIR}/dashboard" ]]; then
    _methods[${#_methods[@]}]="uv"
    _descs[${#_descs[@]}]="fast, recommended"
  fi
  if command -v pip3 >/dev/null 2>&1 || command -v pip >/dev/null 2>&1; then
    if [[ -d "${SCRIPT_DIR}/dashboard" ]]; then
      _methods[${#_methods[@]}]="pip"
      _descs[${#_descs[@]}]="classic"
    fi
  fi
  if command -v docker >/dev/null 2>&1; then
    _methods[${#_methods[@]}]="docker"
    _descs[${#_descs[@]}]="containerized, no local deps"
  fi

  if [[ ${#_methods[@]} -eq 0 ]]; then
    warn "No install method available (need uv, pip, or docker)"
    info "Install one of: uv (https://docs.astral.sh/uv), pip, docker"
    return 1
  fi

  # Let user choose if multiple methods available
  local method="${_methods[0]}"
  if [[ ${#_methods[@]} -gt 1 ]]; then
    local method_idx=0
    ui_select method_idx "Install method" "${_methods[@]}" -- "${_descs[@]}"
    method="${_methods[$method_idx]}"
  else
    info "Using ${method}"
  fi

  case "$method" in
    uv)     _dashboard_via_uv "$port" "$token" ;;
    pip)    _dashboard_via_pip "$port" "$token" ;;
    docker) _dashboard_via_docker "$port" "$token" ;;
  esac
}

_dashboard_via_uv() {
  local port="$1"
  local token="${2:-}"
  local venv_dir="${SCRIPT_DIR}/.venv"

  if [[ ! -d "$venv_dir" ]]; then
    info "Creating virtualenv..."
    uv venv "$venv_dir" >/dev/null 2>&1 || {
      warn "Failed to create virtualenv with uv"
      return 1
    }
  fi

  info "Installing dependencies with uv..."
  uv pip install -q -p "${venv_dir}/bin/python" \
    -r "${SCRIPT_DIR}/requirements.txt" 2>/dev/null || {
    warn "Failed to install dependencies with uv"
    return 1
  }
  ok "Dependencies installed"
  _dashboard_start_process "$port" "${venv_dir}/bin/python" "$token"
}

_dashboard_via_pip() {
  local port="$1"
  local token="${2:-}"
  local venv_dir="${SCRIPT_DIR}/.venv"

  if [[ ! -d "$venv_dir" ]]; then
    info "Creating virtualenv..."
    local py=""
    for cmd in python3 python; do
      command -v "$cmd" >/dev/null 2>&1 && { py="$cmd"; break; }
    done
    if [[ -z "$py" ]]; then
      warn "Python not found"
      return 1
    fi
    "$py" -m venv "$venv_dir" 2>/dev/null || {
      warn "Failed to create virtualenv"
      return 1
    }
  fi

  info "Installing dependencies with pip..."
  "${venv_dir}/bin/pip" install -q \
    -r "${SCRIPT_DIR}/requirements.txt" 2>/dev/null || {
    warn "Failed to install dependencies with pip"
    return 1
  }
  ok "Dependencies installed"
  _dashboard_start_process "$port" "${venv_dir}/bin/python" "$token"
}

_dashboard_via_docker() {
  local port="$1"
  local token="${2:-}"
  local image="aily-dashboard"

  info "Building Docker image..."
  if ! docker build -q -t "$image" "${SCRIPT_DIR}" >/dev/null 2>&1; then
    warn "Docker build failed"
    return 1
  fi
  ok "Image built"

  info "Starting container on port ${port}..."
  local cid
  cid=$(docker run -d --rm \
    --name aily-dashboard \
    -p "${port}:8080" \
    -v "${ENV_FILE}:/app/env:ro" \
    -e AGENT_BRIDGE_ENV=/app/env \
    ${token:+-e DASHBOARD_TOKEN="$token"} \
    "$image" 2>/dev/null) || {
    warn "Failed to start container"
    return 1
  }

  _dashboard_wait_healthy "http://localhost:${port}" || return 1
  ok "Dashboard running (container: ${cid:0:12})"
  info "Stop: docker stop aily-dashboard"
  return 0
}

_dashboard_start_process() {
  local port="$1"
  local py="${2:-}"
  local token="${3:-}"

  # Fallback: find system python if no venv python provided
  if [[ -z "$py" ]]; then
    for cmd in python3 python; do
      command -v "$cmd" >/dev/null 2>&1 && { py="$cmd"; break; }
    done
  fi
  if [[ -z "$py" ]]; then
    warn "Python not found"
    return 1
  fi

  # Local DB path (Docker uses /app/data, local uses ~/.local/share/aily)
  local db_dir="${HOME}/.local/share/aily"
  mkdir -p "$db_dir" 2>/dev/null || {
    db_dir="/tmp/aily-data"
    mkdir -p "$db_dir"
  }

  info "Starting dashboard on port ${port}..."
  PYTHONPATH="${SCRIPT_DIR}" \
    DASHBOARD_HOST="0.0.0.0" DASHBOARD_PORT="$port" \
    DASHBOARD_DB_PATH="${db_dir}/aily.db" \
    AGENT_BRIDGE_ENV="$ENV_FILE" \
    ${token:+DASHBOARD_TOKEN="$token"} \
    nohup "$py" -m dashboard >/tmp/aily-dashboard.log 2>&1 &
  local pid=$!

  _dashboard_wait_healthy "http://localhost:${port}" || {
    info "Check logs: /tmp/aily-dashboard.log"
    return 1
  }
  ok "Dashboard running (PID ${pid})"
  info "Logs: /tmp/aily-dashboard.log"
  info "Stop: kill ${pid}"
  return 0
}

_dashboard_wait_healthy() {
  local url="$1"
  local attempts=0
  while [[ $attempts -lt 15 ]]; do
    sleep 0.5
    if curl -sf --connect-timeout 1 "${url}/healthz" >/dev/null 2>&1; then
      return 0
    fi
    attempts=$((attempts + 1))
  done
  warn "Dashboard not responding after 7s"
  return 1
}

_send_test_notification() {
  load_env
  local timestamp
  timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  local hostname_short
  hostname_short=$(hostname -s 2>/dev/null || hostname)
  local message
  message=$(printf ':white_check_mark: *aily connected!*\n\n:desktop_computer: Host: `%s`\n:clock1: Time: %s\n\nAvailable commands:\n‚Ä¢ `!new <name> [host] [pwd]` ‚Äî Create a tmux session (optionally on a specific host and directory)\n‚Ä¢ `!kill <name>` ‚Äî Kill a tmux session and archive its thread\n‚Ä¢ `!sessions` ‚Äî List all sessions with sync status\n‚Ä¢ `!queue` ‚Äî List / add / execute deferred commands' "$hostname_short" "$timestamp")
  local any_ok=false

  # Post directly to platform APIs (bypasses hook symlinks)
  if [[ -n "${SLACK_BOT_TOKEN:-}" && -n "${SLACK_CHANNEL_ID:-}" ]]; then
    local payload
    payload=$(jq -n --arg ch "$SLACK_CHANNEL_ID" --arg msg "$message" '{channel: $ch, text: $msg, unfurl_links: false}')
    local resp
    resp=$(curl -sf -X POST \
      -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
      -H "Content-Type: application/json; charset=utf-8" \
      -d "$payload" \
      "https://slack.com/api/chat.postMessage" 2>/dev/null || echo "")
    if echo "$resp" | jq -e '.ok == true' >/dev/null 2>&1; then
      any_ok=true
    fi
  fi

  if [[ -n "${DISCORD_BOT_TOKEN:-}" && -n "${DISCORD_CHANNEL_ID:-}" ]]; then
    local discord_msg
    discord_msg=$(printf '‚úÖ **aily connected!**\n\nüñ•Ô∏è Host: `%s`\nüïê Time: %s\n\nAvailable commands:\n‚Ä¢ `!new <name> [host] [pwd]` ‚Äî Create a tmux session (optionally on a specific host and directory)\n‚Ä¢ `!kill <name>` ‚Äî Kill a tmux session and archive its thread\n‚Ä¢ `!sessions` ‚Äî List all sessions with sync status\n‚Ä¢ `!queue` ‚Äî List / add / execute deferred commands' "$hostname_short" "$timestamp")
    local payload
    payload=$(jq -n --arg msg "$discord_msg" '{content: $msg}')
    local resp
    resp=$(curl -sf -X POST \
      -H "Authorization: Bot ${DISCORD_BOT_TOKEN}" \
      -H "Content-Type: application/json" \
      -d "$payload" \
      "https://discord.com/api/v10/channels/${DISCORD_CHANNEL_ID}/messages" 2>/dev/null || echo "")
    if echo "$resp" | jq -e '.id' >/dev/null 2>&1; then
      any_ok=true
    fi
  fi

  if [[ "$any_ok" == "true" ]]; then
    ok "Test notification sent"
  else
    warn "Could not send test notification"
    # Provide actionable diagnostics
    if [[ -z "${SLACK_BOT_TOKEN:-}" && -z "${DISCORD_BOT_TOKEN:-}" ]]; then
      info "No platform tokens configured"
    else
      if [[ -n "${SLACK_BOT_TOKEN:-}" ]]; then
        info "Slack: check bot token and channel ID"
      fi
      if [[ -n "${DISCORD_BOT_TOKEN:-}" ]]; then
        info "Discord: check bot token and channel ID"
      fi
    fi
  fi
}

# Check Discord bot permissions via guild-level permission integer.
# Prints ‚úì/‚úó for each required permission. Returns count of missing.
_check_discord_permissions_box() {
  local token="$1" channel_id="$2"
  local missing=0

  local ch_resp
  ch_resp=$(curl -sf --connect-timeout 5 -H "Authorization: Bot ${token}" \
    "https://discord.com/api/v10/channels/${channel_id}" 2>/dev/null || echo "")
  local guild_id
  guild_id=$(echo "$ch_resp" | jq -r '.guild_id // empty' 2>/dev/null)
  if [[ -z "$guild_id" ]]; then
    box_line "  ${C_YELLOW}‚ö† Could not resolve guild${C_RESET}"
    return 1
  fi

  local guilds_resp
  guilds_resp=$(curl -sf --connect-timeout 5 -H "Authorization: Bot ${token}" \
    "https://discord.com/api/v10/users/@me/guilds" 2>/dev/null || echo "")
  local perms
  perms=$(echo "$guilds_resp" | jq -r ".[] | select(.id == \"${guild_id}\") | .permissions // empty" 2>/dev/null)
  if [[ -z "$perms" ]]; then
    box_line "  ${C_YELLOW}‚ö† Could not read guild permissions${C_RESET}"
    return 1
  fi

  local -a perm_names=("Send Messages" "Read Message History" "Manage Threads" "Create Public Threads" "Send Messages in Threads")
  local -a perm_bits=(2048 65536 17179869184 34359738368 274877906944)

  for i in "${!perm_names[@]}"; do
    local name="${perm_names[$i]}"
    local bit="${perm_bits[$i]}"
    if python3 -c "exit(0 if int('${perms}') & ${bit} else 1)" 2>/dev/null; then
      box_line "  ${C_GREEN}‚úì${C_RESET} ${name}"
    else
      box_line "  ${C_RED}‚úó${C_RESET} ${name}"
      missing=$((missing + 1))
    fi
  done

  box_line "  ${C_DIM}¬∑ Message Content Intent: verify${C_RESET}"

  return $missing
}

_check_discord_permissions() {
  local token="$1" channel_id="$2" indent="${3:-    }"
  local missing=0

  # Get guild_id from channel
  local ch_resp
  ch_resp=$(curl -sf --connect-timeout 5 -H "Authorization: Bot ${token}" \
    "https://discord.com/api/v10/channels/${channel_id}" 2>/dev/null || echo "")
  local guild_id
  guild_id=$(echo "$ch_resp" | jq -r '.guild_id // empty' 2>/dev/null)
  if [[ -z "$guild_id" ]]; then
    printf "${indent}${C_YELLOW}Could not resolve guild${C_RESET}\n"
    return 1
  fi

  # Get bot permissions from guilds list
  local guilds_resp
  guilds_resp=$(curl -sf --connect-timeout 5 -H "Authorization: Bot ${token}" \
    "https://discord.com/api/v10/users/@me/guilds" 2>/dev/null || echo "")
  local perms
  perms=$(echo "$guilds_resp" | jq -r ".[] | select(.id == \"${guild_id}\") | .permissions // empty" 2>/dev/null)
  if [[ -z "$perms" ]]; then
    printf "${indent}${C_YELLOW}Could not read guild permissions${C_RESET}\n"
    return 1
  fi

  # Permission bits: name  decimal_value
  local -a perm_names=("Send Messages" "Read Message History" "Manage Threads" "Create Public Threads" "Send Messages in Threads")
  local -a perm_bits=(2048 65536 17179869184 34359738368 274877906944)

  for i in "${!perm_names[@]}"; do
    local name="${perm_names[$i]}"
    local bit="${perm_bits[$i]}"
    # Use python3 for 64-bit bitwise (bash can't handle large ints on all platforms)
    if python3 -c "exit(0 if int('${perms}') & ${bit} else 1)" 2>/dev/null; then
      printf "${indent}${C_GREEN}‚úì${C_RESET} %s\n" "$name"
    else
      printf "${indent}${C_RED}‚úó${C_RESET} %s\n" "$name"
      missing=$((missing + 1))
    fi
  done

  # Message Content Intent ‚Äî can't be checked via API, just hint
  printf "${indent}${C_DIM}¬∑ Message Content Intent: verify in Developer Portal${C_RESET}\n"

  return $missing
}

# Check Slack bot permissions by probing API endpoints.
# Prints ‚úì/‚úó for each required scope. Returns count of missing.
_check_slack_permissions() {
  local token="$1" channel_id="$2" indent="${3:-    }"
  local missing=0

  # Helper: call Slack API and check result
  _slack_check() {
    local label="$1" url="$2"
    local resp
    resp=$(curl -sf --connect-timeout 5 -H "Authorization: Bearer ${token}" "$url" 2>/dev/null || echo "")
    local ok_val err_val
    ok_val=$(echo "$resp" | jq -r '.ok // empty' 2>/dev/null)
    err_val=$(echo "$resp" | jq -r '.error // empty' 2>/dev/null)
    if [[ "$ok_val" == "true" ]]; then
      printf "${indent}${C_GREEN}‚úì${C_RESET} %s\n" "$label"
      return 0
    else
      if [[ "$err_val" == "missing_scope" ]]; then
        local needed
        needed=$(echo "$resp" | jq -r '.needed // empty' 2>/dev/null)
        printf "${indent}${C_RED}‚úó${C_RESET} %s (need: %s)\n" "$label" "$needed"
      elif [[ "$err_val" == "not_in_channel" || "$err_val" == "channel_not_found" ]]; then
        printf "${indent}${C_RED}‚úó${C_RESET} %s (bot not in channel)\n" "$label"
      else
        printf "${indent}${C_RED}‚úó${C_RESET} %s (%s)\n" "$label" "${err_val:-unknown error}"
      fi
      return 1
    fi
  }

  _slack_check "channels:read" "https://slack.com/api/conversations.info?channel=${channel_id}" || missing=$((missing + 1))
  _slack_check "channels:history" "https://slack.com/api/conversations.history?channel=${channel_id}&limit=1" || missing=$((missing + 1))

  # chat:write ‚Äî check via auth.test (can't safely test without posting)
  local auth_resp
  auth_resp=$(curl -sf --connect-timeout 5 -H "Authorization: Bearer ${token}" \
    "https://slack.com/api/auth.test" 2>/dev/null || echo "")
  if echo "$auth_resp" | jq -e '.ok == true' >/dev/null 2>&1; then
    printf "${indent}${C_GREEN}‚úì${C_RESET} chat:write (token valid)\n"
  else
    printf "${indent}${C_RED}‚úó${C_RESET} chat:write (token invalid)\n"
    missing=$((missing + 1))
  fi

  # reactions:write ‚Äî can't test without side effects, just note
  printf "${indent}${C_DIM}¬∑ reactions:write: verify in App Settings${C_RESET}\n"

  unset -f _slack_check
  return $missing
}

_check_slack_permissions_box() {
  local token="$1" channel_id="$2"
  local missing=0

  _slack_check_box() {
    local label="$1" url="$2"
    local resp
    resp=$(curl -sf --connect-timeout 5 -H "Authorization: Bearer ${token}" "$url" 2>/dev/null || echo "")
    local ok_val err_val
    ok_val=$(echo "$resp" | jq -r '.ok // empty' 2>/dev/null)
    err_val=$(echo "$resp" | jq -r '.error // empty' 2>/dev/null)
    if [[ "$ok_val" == "true" ]]; then
      box_line "  ${C_GREEN}‚úì${C_RESET} ${label}"
      return 0
    else
      if [[ "$err_val" == "missing_scope" ]]; then
        local needed
        needed=$(echo "$resp" | jq -r '.needed // empty' 2>/dev/null)
        box_line "  ${C_RED}‚úó${C_RESET} ${label} (need: ${needed})"
      elif [[ "$err_val" == "not_in_channel" || "$err_val" == "channel_not_found" ]]; then
        box_line "  ${C_RED}‚úó${C_RESET} ${label} (bot not in channel)"
      else
        box_line "  ${C_RED}‚úó${C_RESET} ${label} (${err_val:-unknown})"
      fi
      return 1
    fi
  }

  _slack_check_box "channels:read" "https://slack.com/api/conversations.info?channel=${channel_id}" || missing=$((missing + 1))
  _slack_check_box "channels:history" "https://slack.com/api/conversations.history?channel=${channel_id}&limit=1" || missing=$((missing + 1))

  local auth_resp
  auth_resp=$(curl -sf --connect-timeout 5 -H "Authorization: Bearer ${token}" \
    "https://slack.com/api/auth.test" 2>/dev/null || echo "")
  if echo "$auth_resp" | jq -e '.ok == true' >/dev/null 2>&1; then
    box_line "  ${C_GREEN}‚úì${C_RESET} chat:write (token valid)"
  else
    box_line "  ${C_RED}‚úó${C_RESET} chat:write (token invalid)"
    missing=$((missing + 1))
  fi

  box_line "  ${C_DIM}¬∑ reactions:write: verify in App Settings${C_RESET}"

  unset -f _slack_check_box
  return $missing
}

# -------------------------------------------------------------------
# aily status
# -------------------------------------------------------------------
cmd_status() {
  require_deps
  load_env

  echo ""
  box_top "aily status"
  box_empty

  # -- Platforms --
  box_line "${C_BOLD}Platforms${C_RESET}"

  # Discord
  if [[ -n "${DISCORD_BOT_TOKEN:-}" && -n "${DISCORD_CHANNEL_ID:-}" ]]; then
    local discord_resp
    discord_resp=$(curl -sf --connect-timeout 3 -H "Authorization: Bot ${DISCORD_BOT_TOKEN}" \
      "https://discord.com/api/v10/channels/${DISCORD_CHANNEL_ID}" 2>/dev/null || echo "")
    if [[ -n "$discord_resp" ]] && echo "$discord_resp" | jq -e '.id' >/dev/null 2>&1; then
      local chan_name
      chan_name=$(echo "$discord_resp" | jq -r '.name // "unknown"')
      box_line "${C_GREEN}‚óè${C_RESET} Discord   ${C_GREEN}connected${C_RESET}  #${chan_name}"
    else
      box_line "${C_YELLOW}‚óè${C_RESET} Discord   ${C_YELLOW}unreachable${C_RESET}"
    fi
  else
    box_line "${C_DIM}‚óã Discord   not configured${C_RESET}"
  fi

  # Slack
  if [[ -n "${SLACK_BOT_TOKEN:-}" && -n "${SLACK_CHANNEL_ID:-}" ]]; then
    local slack_resp
    slack_resp=$(curl -sf --connect-timeout 3 -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
      "https://slack.com/api/conversations.info?channel=${SLACK_CHANNEL_ID}" 2>/dev/null || echo "")
    if [[ -n "$slack_resp" ]] && echo "$slack_resp" | jq -e '.ok == true' >/dev/null 2>&1; then
      local chan_name
      chan_name=$(echo "$slack_resp" | jq -r '.channel.name // "unknown"')
      box_line "${C_GREEN}‚óè${C_RESET} Slack     ${C_GREEN}connected${C_RESET}  #${chan_name}"
    else
      box_line "${C_YELLOW}‚óè${C_RESET} Slack     ${C_YELLOW}unreachable${C_RESET}"
    fi
  else
    box_line "${C_DIM}‚óã Slack     not configured${C_RESET}"
  fi

  box_empty
  box_sep

  # -- Hooks & Agents --
  box_empty
  local hook_files=(notify-claude.sh notify-gemini.sh notify-codex.py notify-opencode.mjs post.sh thread-sync.sh discord-lib.sh slack-lib.sh)
  local hook_count=0
  local hook_total=${#hook_files[@]}
  for hf in "${hook_files[@]}"; do
    local target="${HOOKS_DIR}/${hf}"
    if [[ -L "$target" || -f "$target" ]]; then
      hook_count=$((hook_count + 1))
    fi
  done
  local hook_bar
  hook_bar=$(_progress_bar $hook_count $hook_total 16)
  local hook_icon="${C_GREEN}‚úì${C_RESET}"
  [[ $hook_count -lt $hook_total ]] && hook_icon="${C_YELLOW}!${C_RESET}"
  box_line "Hooks    ${C_BOLD}${hook_count}/${hook_total}${C_RESET}  ${C_GREEN}${hook_bar}${C_RESET} ${hook_icon}"

  local agent_count=0
  local agent_total=4
  local claude_settings="$HOME/.claude/settings.json"
  [[ -f "$claude_settings" ]] && grep -q "notify-clawdia\|notify-claude" "$claude_settings" 2>/dev/null && agent_count=$((agent_count + 1))
  local codex_config="$HOME/.codex/config.toml"
  [[ -f "$codex_config" ]] && grep -q "notify-codex" "$codex_config" 2>/dev/null && agent_count=$((agent_count + 1))
  local gemini_settings="$HOME/.gemini/settings.json"
  [[ -f "$gemini_settings" ]] && grep -q "notify-gemini" "$gemini_settings" 2>/dev/null && agent_count=$((agent_count + 1))
  local opencode_plugins="$HOME/.config/opencode/plugins"
  [[ -d "$opencode_plugins" ]] && find "$opencode_plugins" -maxdepth 1 \( -name "aily*" -o -name "notify-opencode*" \) -print -quit 2>/dev/null | grep -q . && agent_count=$((agent_count + 1))

  local agent_bar
  agent_bar=$(_progress_bar $agent_count $agent_total 16)
  local agent_icon="${C_GREEN}‚úì${C_RESET}"
  [[ $agent_count -lt $agent_total ]] && agent_icon="${C_YELLOW}!${C_RESET}"
  box_line "Agents   ${C_BOLD}${agent_count}/${agent_total}${C_RESET}  ${C_GREEN}${agent_bar}${C_RESET} ${agent_icon}"

  box_empty
  box_sep

  # -- SSH & tmux --
  box_empty
  box_line "${C_BOLD}SSH hosts${C_RESET}"
  local hosts_str
  hosts_str=$(env_get "SSH_HOSTS" "localhost")
  IFS=',' read -ra hosts <<< "$hosts_str"
  for host in "${hosts[@]}"; do
    host=$(echo "$host" | tr -d ' ')
    if [[ "$host" == "localhost" ]]; then
      box_line "${C_GREEN}‚óè${C_RESET} ${host}  ${C_DIM}local${C_RESET}"
    elif ssh -o ConnectTimeout=2 -o BatchMode=yes "$host" "echo ok" >/dev/null 2>&1; then
      box_line "${C_GREEN}‚óè${C_RESET} ${host}  ${C_GREEN}reachable${C_RESET}"
    else
      box_line "${C_RED}‚óè${C_RESET} ${host}  ${C_RED}unreachable${C_RESET}"
    fi
  done

  box_empty

  local session_count="0"
  if command -v tmux >/dev/null 2>&1 && tmux list-sessions >/dev/null 2>&1; then
    session_count=$(tmux list-sessions -F '#{session_name}' 2>/dev/null | grep -cv '^aily-bridge$\|^slack-bridge$\|^aily-dashboard$' || echo "0")
  fi
  local sync_status
  sync_status=$(env_get "TMUX_THREAD_SYNC" "true")
  local cleanup_status
  cleanup_status=$(env_get "THREAD_CLEANUP" "archive")
  box_line "tmux  ${C_BOLD}${session_count}${C_RESET} sessions ${C_DIM}¬∑ sync:${sync_status} ¬∑ ${cleanup_status}${C_RESET}"

  box_empty
  box_sep

  # -- Services --
  box_empty
  if tmux has-session -t "${BRIDGE_SESSION:-aily-bridge}" 2>/dev/null; then
    box_line "${C_GREEN}‚óè${C_RESET} Bridge      ${C_GREEN}running${C_RESET}  ${C_DIM}(tmux: aily-bridge)${C_RESET}"
  else
    box_line "${C_DIM}‚óã Bridge      not running${C_RESET}"
  fi
  local dash_url
  dash_url=$(env_get "AILY_DASHBOARD_URL" "")
  if [[ -n "$dash_url" ]]; then
    if _dashboard_is_running || curl -sf --connect-timeout 1 "${dash_url}/healthz" >/dev/null 2>&1; then
      box_line "${C_GREEN}‚óè${C_RESET} Dashboard   ${C_GREEN}running${C_RESET}  ${C_DIM}${dash_url}${C_RESET}"
    else
      box_line "${C_DIM}‚óã Dashboard   stopped${C_RESET}   ${C_DIM}${dash_url}${C_RESET}"
    fi
  else
    box_line "${C_DIM}‚óã Dashboard   not configured${C_RESET}"
  fi

  box_empty
  box_bottom
  echo ""
}

# -------------------------------------------------------------------
# aily sessions
# -------------------------------------------------------------------
cmd_sessions() {
  require_deps

  local output_json="${AILY_JSON}"
  local source="dashboard"  # default: try dashboard first, fall back to ssh

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json) output_json=true; shift ;;
      --ssh)  source="ssh"; shift ;;
      *) shift ;;
    esac
  done

  if [[ "$source" == "ssh" ]]; then
    _sessions_ssh "$output_json"
    return
  fi

  # Try dashboard API first
  local resp
  resp=$(api_call GET "/api/sessions?status=active" 2>/dev/null || echo "")

  if [[ -n "$resp" ]] && echo "$resp" | jq -e '.' >/dev/null 2>&1; then
    if json_output "$resp"; then
      return
    fi
    if [[ "$output_json" == "true" ]]; then
      printf '%s\n' "$resp"
      return
    fi

    local count
    count=$(echo "$resp" | jq 'if type == "array" then length else (.sessions // []) | length end')
    if [[ "$count" == "0" || "$count" == "null" ]]; then
      info "No active sessions"
      return
    fi

    hdr "Active sessions (${count})"
    echo ""
    printf "  ${C_BOLD}%-24s %-16s %-10s %-10s %s${C_RESET}\n" "NAME" "HOST" "STATUS" "AGENT" "UPDATED"
    printf "  %-24s %-16s %-10s %-10s %s\n" "------------------------" "----------------" "----------" "----------" "-------------------"

    # Handle both array and object-with-sessions response formats
    echo "$resp" | jq -r '
      (if type == "array" then . else (.sessions // []) end)[]
      | [
          (.name // "-"),
          (.host // "-"),
          (.status // "-"),
          (.agent_type // "-"),
          (.updated_at // "-" | split("T") | if length > 1 then .[0] + " " + (.[1] | split(".")[0]) else .[0] end)
        ]
      | @tsv
    ' 2>/dev/null | while IFS=$'\t' read -r name host status agent updated; do
      local status_color="$C_RESET"
      case "$status" in
        active)   status_color="$C_GREEN" ;;
        idle)     status_color="$C_YELLOW" ;;
        closed)   status_color="$C_DIM" ;;
      esac
      printf "  %-24s %-16s ${status_color}%-10s${C_RESET} %-10s %s\n" \
        "$name" "$host" "$status" "$agent" "$updated"
    done
    echo ""
  else
    # Fall back to SSH-based session listing
    if [[ "$output_json" != "true" && "$AILY_JSON" != true ]]; then
      info "Dashboard unavailable, falling back to SSH..."
    fi
    _sessions_ssh "$output_json"
  fi
}

_sessions_ssh() {
  local json_output="${1:-false}"
  load_env

  local hosts_str
  hosts_str=$(env_get "SSH_HOSTS" "localhost")
  IFS=',' read -ra hosts <<< "$hosts_str"

  if [[ "$json_output" == "true" ]]; then
    echo "["
    local first=true
    for host in "${hosts[@]}"; do
      host=$(echo "$host" | tr -d ' ')
      local sessions
      if [[ "$host" == "localhost" ]]; then
        sessions=$(tmux list-sessions -F '#{session_name}' 2>/dev/null || echo "")
      else
        sessions=$(ssh -o ConnectTimeout=3 -o BatchMode=yes "$host" \
          "tmux list-sessions -F '#{session_name}' 2>/dev/null" 2>/dev/null || echo "")
      fi
      while IFS= read -r name; do
        [[ -z "$name" ]] && continue
        if [[ "$first" == "true" ]]; then first=false; else echo ","; fi
        printf '  {"name": "%s", "host": "%s"}' "$name" "$host"
      done <<< "$sessions"
    done
    echo ""
    echo "]"
    return
  fi

  hdr "tmux sessions (via SSH)"
  echo ""

  for host in "${hosts[@]}"; do
    host=$(echo "$host" | tr -d ' ')
    local sessions
    if [[ "$host" == "localhost" ]]; then
      sessions=$(tmux list-sessions -F '#{session_name}' 2>/dev/null || echo "")
    else
      sessions=$(ssh -o ConnectTimeout=3 -o BatchMode=yes "$host" \
        "tmux list-sessions -F '#{session_name}' 2>/dev/null" 2>/dev/null || echo "")
    fi
    if [[ -n "$sessions" ]]; then
      printf "  ${C_BOLD}%s${C_RESET}\n" "$host"
      while IFS= read -r name; do
        [[ -z "$name" ]] && continue
        echo "    $name"
      done <<< "$sessions"
      echo ""
    else
      printf "  ${C_DIM}%s (no sessions)${C_RESET}\n" "$host"
    fi
  done
}

# -------------------------------------------------------------------
# aily sync [session-name]
# -------------------------------------------------------------------
cmd_sync() {
  require_deps

  local session_name="${1:-}"
  if [[ -z "$session_name" ]]; then
    session_name=$(detect_tmux_session)
  fi
  if [[ -z "$session_name" ]]; then
    err "No session name provided and not inside tmux"
    echo "  Usage: aily sync <session-name>" >&2
    exit 1
  fi

  printf "  Syncing session '%s'... " "$session_name"
  local resp
  resp=$(api_call POST "/api/sessions/${session_name}/sync" 2>/dev/null || echo "")

  if [[ -n "$resp" ]]; then
    local count
    count=$(echo "$resp" | jq -r '.synced_messages // .count // "unknown"' 2>/dev/null)
    printf "${C_GREEN}OK${C_RESET}\n"
    info "Synced messages: ${count}"
  else
    printf "${C_RED}FAILED${C_RESET}\n"
    err "Could not sync session. Is the dashboard reachable?"
  fi
}

# -------------------------------------------------------------------
# aily logs [session-name]
# -------------------------------------------------------------------
cmd_logs() {
  require_deps

  local session_name="" limit=20 json_output=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json)    json_output=true; shift ;;
      --limit)   limit="$2"; shift 2 ;;
      -n)        limit="$2"; shift 2 ;;
      -*)        shift ;;
      *)
        if [[ -z "$session_name" ]]; then
          session_name="$1"
        fi
        shift
        ;;
    esac
  done

  if [[ -z "$session_name" ]]; then
    session_name=$(detect_tmux_session)
  fi
  if [[ -z "$session_name" ]]; then
    err "No session name provided and not inside tmux"
    echo "  Usage: aily logs <session-name>" >&2
    exit 1
  fi

  local resp
  resp=$(api_call GET "/api/sessions/${session_name}/messages?limit=${limit}" 2>/dev/null || echo "")

  if [[ -z "$resp" ]]; then
    err "Could not fetch messages. Is the dashboard reachable?"
    exit 1
  fi

  if [[ "$json_output" == "true" ]]; then
    echo "$resp" | jq .
    return
  fi

  local count
  count=$(echo "$resp" | jq 'if type == "array" then length else (.messages // []) | length end' 2>/dev/null)

  if [[ "$count" == "0" || "$count" == "null" || -z "$count" ]]; then
    info "No messages for session '${session_name}'"
    return
  fi

  hdr "Messages for ${session_name} (${count})"
  echo ""

  echo "$resp" | jq -r '
    (if type == "array" then . else (.messages // []) end)[]
    | "\(.role // "unknown")\t\(.content // "")\t\(.created_at // "-")"
  ' 2>/dev/null | while IFS=$'\t' read -r role content timestamp; do
    local role_color="$C_RESET"
    local role_label="$role"
    case "$role" in
      user|human)     role_color="$C_BLUE"; role_label="user" ;;
      assistant|ai)   role_color="$C_GREEN"; role_label="assistant" ;;
      system)         role_color="$C_MAGENTA"; role_label="system" ;;
      tool)           role_color="$C_CYAN"; role_label="tool" ;;
    esac

    local ts_short
    ts_short=$(echo "$timestamp" | sed 's/T/ /; s/\..*//')
    printf "  ${C_DIM}%s${C_RESET} ${role_color}${C_BOLD}[%s]${C_RESET} %s\n" \
      "$ts_short" "$role_label" "$content"
  done
  echo ""
}

# -------------------------------------------------------------------
# aily attach [session-name]
# -------------------------------------------------------------------
cmd_attach() {
  require_cmd tmux "install via your package manager" || return 1

  local session_name="${1:-}"
  if [[ -z "$session_name" ]]; then
    printf "${C_BOLD}Active tmux sessions:${C_RESET}\n"
    tmux list-sessions 2>/dev/null || { err "No tmux sessions found"; return 1; }
    printf "\n"
    read -rp "Session name: " session_name
    [[ -z "$session_name" ]] && return 1
  fi

  if tmux has-session -t "$session_name" 2>/dev/null; then
    exec tmux attach-session -t "$session_name"
  else
    err "Session '$session_name' not found"
    return 1
  fi
}

# -------------------------------------------------------------------
# aily export <session-name> [json|markdown]
# -------------------------------------------------------------------
cmd_export() {
  require_cmd curl "install via your package manager" || return 1

  local session_name="${1:-}"
  local format="${2:-markdown}"

  if [[ -z "$session_name" ]]; then
    err "Usage: aily export <session-name> [json|markdown]"
    return 1
  fi

  case "$format" in
    json|markdown) ;;
    *)
      err "Invalid format '${format}'. Use: json or markdown"
      return 1
      ;;
  esac

  local dashboard_url_value
  dashboard_url_value="$(dashboard_url)"
  if [[ -z "$dashboard_url_value" ]]; then
    err "Dashboard URL not configured. Run: aily config set dashboard_url <url>"
    return 1
  fi

  local token
  token="$(dashboard_token)"

  # Build a safe local filename from session name to prevent path traversal.
  local output_stem="$session_name"
  output_stem="${output_stem##*/}"
  output_stem="${output_stem##*\\}"
  output_stem="$(printf '%s' "$output_stem" | tr -c 'A-Za-z0-9._-:' '_')"
  if [[ -z "$output_stem" || "$output_stem" == "." || "$output_stem" == ".." ]]; then
    output_stem="session"
  fi

  local output_file
  if [[ "$format" == "json" ]]; then
    output_file="${output_stem}.json"
  else
    output_file="${output_stem}.md"
  fi

  local session_name_encoded
  if command -v python3 >/dev/null 2>&1; then
    session_name_encoded="$(python3 -c 'import sys, urllib.parse; print(urllib.parse.quote(sys.argv[1], safe=""))' "$session_name" 2>/dev/null || echo "")"
  elif command -v jq >/dev/null 2>&1; then
    session_name_encoded="$(jq -rn --arg v "$session_name" '$v|@uri' 2>/dev/null || echo "")"
  fi
  if [[ -z "$session_name_encoded" ]]; then
    err "Could not encode session name for export URL (requires python3 or jq)"
    return 1
  fi

  printf "Exporting session '%s' as %s...\n" "$session_name" "$format"

  local curl_args=(-sf)
  if [[ -n "$token" ]]; then
    curl_args+=(-H "Authorization: Bearer $token")
  fi

  if curl "${curl_args[@]}" "${dashboard_url_value}/api/sessions/${session_name_encoded}/export?format=${format}" -o "$output_file"; then
    if [[ -f "$output_file" ]]; then
      ok "Exported to $output_file ($(wc -c < "$output_file" | tr -d ' ') bytes)"
      return 0
    fi
  fi

  err "Export failed"
  return 1
}

# -------------------------------------------------------------------
# aily config
# -------------------------------------------------------------------
cmd_config() {
  local subcmd="${1:-show}"
  shift 2>/dev/null || true

  case "$subcmd" in
    show)
      _config_show
      ;;
    set)
      _config_set "$@"
      ;;
    dashboard-url)
      local new_url="${1:-}"
      if [[ -z "$new_url" ]]; then
        err "Usage: aily config dashboard-url <URL>"
        exit 1
      fi
      env_set "AILY_DASHBOARD_URL" "$new_url"
      ok "AILY_DASHBOARD_URL = ${new_url}"
      ;;
    *)
      err "Unknown config subcommand: ${subcmd}"
      echo "  Usage:" >&2
      echo "    aily config show                  Show current configuration" >&2
      echo "    aily config set KEY VALUE         Set a configuration key" >&2
      echo "    aily config dashboard-url URL     Shortcut for dashboard URL" >&2
      exit 1
      ;;
  esac
}

_config_show() {
  if [[ ! -f "$ENV_FILE" ]]; then
    err "No configuration file found at ${ENV_FILE}"
    info "Run 'aily init' to create one"
    exit 1
  fi

  hdr "Configuration (${ENV_FILE})"
  echo ""

  # Read and redact sensitive values
  local secret_keys="DISCORD_BOT_TOKEN SLACK_BOT_TOKEN SLACK_APP_TOKEN AILY_AUTH_TOKEN TELEGRAM_BOT_TOKEN"
  while IFS= read -r line; do
    # Skip empty lines and comments ‚Äî print as-is
    if [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]]; then
      echo "  $line"
      continue
    fi
    if [[ "$line" =~ ^([A-Z_]+)=(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local val="${BASH_REMATCH[2]}"
      # Strip quotes
      val="${val#\"}"
      val="${val%\"}"
      val="${val#\'}"
      val="${val%\'}"

      if [[ " $secret_keys " == *" $key "* && -n "$val" ]]; then
        printf "  ${C_CYAN}%s${C_RESET}=%s\n" "$key" "$(redact "$val")"
      else
        printf "  ${C_CYAN}%s${C_RESET}=%s\n" "$key" "$val"
      fi
    else
      echo "  $line"
    fi
  done < "$ENV_FILE"
  echo ""
}

_config_set() {
  local key="${1:-}" value="${2:-}"
  if [[ -z "$key" || -z "$value" ]]; then
    err "Usage: aily config set KEY VALUE"
    exit 1
  fi
  # Normalize key to uppercase
  key=$(echo "$key" | tr '[:lower:]' '[:upper:]')
  env_set "$key" "$value"
  ok "${key} updated"
}

# -------------------------------------------------------------------
# aily doctor
# -------------------------------------------------------------------
cmd_doctor() {
  require_deps

  local issues=0

  echo ""
  box_top "aily doctor"
  box_empty

  # Dependencies
  box_line "${C_BOLD}Dependencies${C_RESET}"
  local dep_line1="" dep_line2=""
  local dep_count=0
  for cmd in curl jq tmux ssh python3; do
    local mark="" ver=""
    if command -v "$cmd" >/dev/null 2>&1; then
      case "$cmd" in
        curl)    ver=$(curl --version 2>/dev/null | head -1 | awk '{print $2}') ;;
        jq)      ver=$(jq --version 2>/dev/null | tr -d 'jq-') ;;
        tmux)    ver=$(tmux -V 2>/dev/null | awk '{print $2}') ;;
        ssh)     ver="" ;;
        python3) ver=$(python3 --version 2>/dev/null | awk '{print $2}') ;;
      esac
      if [[ -n "$ver" ]]; then
        mark="${C_GREEN}‚úì${C_RESET} ${cmd} ${ver}"
      else
        mark="${C_GREEN}‚úì${C_RESET} ${cmd}"
      fi
    else
      if [[ "$cmd" == "curl" || "$cmd" == "jq" ]]; then
        mark="${C_RED}‚úó${C_RESET} ${cmd}"
        issues=$((issues + 1))
      else
        mark="${C_DIM}¬∑ ${cmd}${C_RESET}"
      fi
    fi
    dep_count=$((dep_count + 1))
    if [[ $dep_count -le 3 ]]; then
      [[ -n "$dep_line1" ]] && dep_line1+="   "
      dep_line1+="$mark"
    else
      [[ -n "$dep_line2" ]] && dep_line2+="   "
      dep_line2+="$mark"
    fi
  done
  box_line "$dep_line1"
  [[ -n "$dep_line2" ]] && box_line "$dep_line2"

  box_empty
  box_sep

  # Config file
  box_empty
  box_line "${C_BOLD}Config${C_RESET}"
  if [[ -f "$ENV_FILE" ]]; then
    local perms
    perms=$(stat -f '%Lp' "$ENV_FILE" 2>/dev/null || stat -c '%a' "$ENV_FILE" 2>/dev/null || echo "unknown")
    if [[ "$perms" == "600" ]]; then
      box_line "${C_GREEN}‚úì${C_RESET} ${ENV_FILE} (${perms})"
    else
      box_line "${C_YELLOW}‚ö†${C_RESET} ${ENV_FILE} (${perms}, expected 600)"
      issues=$((issues + 1))
    fi
  else
    box_line "${C_RED}‚úó${C_RESET} Config not found at ${ENV_FILE}"
    issues=$((issues + 1))
  fi

  # Dashboard (optional)
  local url
  url=$(env_get "AILY_DASHBOARD_URL" "")
  if [[ -n "$url" ]]; then
    if curl -sf --connect-timeout 5 "${url}/healthz" >/dev/null 2>&1; then
      box_line "${C_GREEN}‚úì${C_RESET} Dashboard ${C_GREEN}reachable${C_RESET}"
    else
      box_line "${C_RED}‚úó${C_RESET} Dashboard ${C_RED}unreachable${C_RESET}"
      issues=$((issues + 1))
    fi
    local token
    token=$(dashboard_token)
    if [[ -n "$token" ]]; then
      if curl -sf --connect-timeout 5 -H "Authorization: Bearer ${token}" "${url}/api/stats" >/dev/null 2>&1; then
        box_line "  ${C_GREEN}‚úì${C_RESET} Auth token valid"
      else
        box_line "  ${C_YELLOW}‚ö†${C_RESET} Auth token invalid"
        issues=$((issues + 1))
      fi
    fi
  else
    box_line "${C_DIM}‚óã Dashboard  not configured (optional)${C_RESET}"
  fi

  box_empty
  box_sep

  # Platform APIs
  box_empty
  load_env

  if [[ -n "${DISCORD_BOT_TOKEN:-}" && -n "${DISCORD_CHANNEL_ID:-}" ]]; then
    local discord_resp
    discord_resp=$(curl -sf --connect-timeout 5 -H "Authorization: Bot ${DISCORD_BOT_TOKEN}" \
      "https://discord.com/api/v10/channels/${DISCORD_CHANNEL_ID}" 2>/dev/null || echo "")
    if [[ -n "$discord_resp" ]] && echo "$discord_resp" | jq -e '.id' >/dev/null 2>&1; then
      box_line "${C_BOLD}Discord API${C_RESET}  ${C_GREEN}‚óè OK${C_RESET}"
      _check_discord_permissions_box "${DISCORD_BOT_TOKEN}" "${DISCORD_CHANNEL_ID}" || issues=$((issues + $?))
    else
      box_line "${C_BOLD}Discord API${C_RESET}  ${C_RED}‚óè FAILED${C_RESET}"
      issues=$((issues + 1))
    fi
  else
    box_line "${C_DIM}‚óã Discord   not configured${C_RESET}"
  fi

  if [[ -n "${SLACK_BOT_TOKEN:-}" && -n "${SLACK_CHANNEL_ID:-}" ]]; then
    local slack_resp
    slack_resp=$(curl -sf --connect-timeout 5 -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
      "https://slack.com/api/auth.test" 2>/dev/null || echo "")
    if [[ -n "$slack_resp" ]] && echo "$slack_resp" | jq -e '.ok == true' >/dev/null 2>&1; then
      box_line "${C_BOLD}Slack API${C_RESET}    ${C_GREEN}‚óè OK${C_RESET}"
      _check_slack_permissions_box "${SLACK_BOT_TOKEN}" "${SLACK_CHANNEL_ID}" || issues=$((issues + $?))
    else
      box_line "${C_BOLD}Slack API${C_RESET}    ${C_RED}‚óè FAILED${C_RESET}"
      issues=$((issues + 1))
    fi
  else
    box_line "${C_DIM}‚óã Slack     not configured${C_RESET}"
  fi

  box_empty
  box_sep

  # Hooks & Agents progress
  box_empty
  local expected_hooks=(notify-claude.sh notify-gemini.sh notify-codex.py notify-opencode.mjs post.sh thread-sync.sh discord-lib.sh slack-lib.sh)
  local hook_count=0
  local hook_total=${#expected_hooks[@]}
  local broken_hooks=()
  local missing_hooks=()
  for hf in "${expected_hooks[@]}"; do
    local target="${HOOKS_DIR}/${hf}"
    if [[ -L "$target" ]]; then
      if [[ -f "$target" ]]; then
        hook_count=$((hook_count + 1))
      else
        broken_hooks+=("$hf")
        issues=$((issues + 1))
      fi
    elif [[ -f "$target" ]]; then
      hook_count=$((hook_count + 1))
    else
      missing_hooks+=("$hf")
    fi
  done
  issues=$((issues + ${#missing_hooks[@]}))

  local hook_bar
  hook_bar=$(_progress_bar $hook_count $hook_total 16)
  local hook_icon="${C_GREEN}‚úì${C_RESET}"
  [[ $hook_count -lt $hook_total ]] && hook_icon="${C_YELLOW}!${C_RESET}"
  box_line "Hooks    ${C_BOLD}${hook_count}/${hook_total}${C_RESET}  ${C_GREEN}${hook_bar}${C_RESET} ${hook_icon}"

  local agent_count=0
  local agent_total=4
  local claude_settings="$HOME/.claude/settings.json"
  [[ -f "$claude_settings" ]] && grep -q "notify-clawdia\|notify-claude" "$claude_settings" 2>/dev/null && agent_count=$((agent_count + 1))
  local codex_config="$HOME/.codex/config.toml"
  [[ -f "$codex_config" ]] && grep -q "notify-codex" "$codex_config" 2>/dev/null && agent_count=$((agent_count + 1))
  local gemini_settings="$HOME/.gemini/settings.json"
  [[ -f "$gemini_settings" ]] && grep -q "notify-gemini" "$gemini_settings" 2>/dev/null && agent_count=$((agent_count + 1))
  local opencode_plugins="$HOME/.config/opencode/plugins"
  [[ -d "$opencode_plugins" ]] && find "$opencode_plugins" -maxdepth 1 \( -name "aily*" -o -name "notify-opencode*" \) -print -quit 2>/dev/null | grep -q . && agent_count=$((agent_count + 1))

  local agent_bar
  agent_bar=$(_progress_bar $agent_count $agent_total 16)
  local agent_icon="${C_GREEN}‚úì${C_RESET}"
  [[ $agent_count -lt $agent_total ]] && agent_icon="${C_YELLOW}!${C_RESET}"
  box_line "Agents   ${C_BOLD}${agent_count}/${agent_total}${C_RESET}  ${C_GREEN}${agent_bar}${C_RESET} ${agent_icon}"

  box_empty

  # Bottom with issue count
  if [[ $issues -eq 0 ]]; then
    box_bottom "${C_GREEN}0 issues${C_RESET}"
  else
    box_bottom "${C_YELLOW}${issues} issue(s)${C_RESET}"
  fi
  echo ""
}

# -------------------------------------------------------------------
# aily start [name]
# -------------------------------------------------------------------
cmd_start() {
  local session_name="${1:-}"
  if [[ -z "$session_name" ]]; then
    session_name=$(detect_tmux_session)
  fi
  if [[ -z "$session_name" ]]; then
    err "Not inside tmux. Provide a session name: aily start <name>"
    exit 1
  fi

  local hostname_short
  hostname_short=$(hostname -s 2>/dev/null || hostname)
  local thread_name
  thread_name=$(format_thread_name "$session_name" "$hostname_short")
  local timestamp
  timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  local any_ok=false

  info "Starting thread for ${session_name}..."

  if load_discord_env 2>/dev/null; then
    local thread_id
    thread_id=$(discord_ensure_thread "$thread_name" "tmux session: ${thread_name} (${hostname_short})")
    if [[ -n "$thread_id" ]]; then
      discord_post_to_thread "$thread_id" "Session \`${session_name}\` started on \`${hostname_short}\` ¬∑ ${timestamp}"
      ok "[discord] Thread ready"
      any_ok=true
    else
      err "[discord] Failed to create thread"
    fi
  fi

  if load_slack_env 2>/dev/null; then
    local thread_ts
    thread_ts=$(slack_ensure_thread "$thread_name" "tmux session: ${thread_name} (${hostname_short})")
    if [[ -n "$thread_ts" ]]; then
      slack_post_to_thread "$thread_ts" "Session \`${session_name}\` started on \`${hostname_short}\` ¬∑ ${timestamp}"
      ok "[slack] Thread ready"
      any_ok=true
    else
      err "[slack] Failed to create thread"
    fi
  fi

  if [[ "$any_ok" == false ]]; then
    err "No platforms configured. Check ${ENV_FILE}"
    exit 1
  fi
}

# -------------------------------------------------------------------
# aily stop [name]
# -------------------------------------------------------------------
cmd_stop() {
  local session_name="${1:-}"
  if [[ -z "$session_name" ]]; then
    session_name=$(detect_tmux_session)
  fi
  if [[ -z "$session_name" ]]; then
    err "Not inside tmux. Provide a session name: aily stop <name>"
    exit 1
  fi

  local hostname_short
  hostname_short=$(hostname -s 2>/dev/null || hostname)
  local thread_name
  thread_name=$(format_thread_name "$session_name" "$hostname_short")
  local timestamp
  timestamp=$(date '+%Y-%m-%d %H:%M:%S')

  load_env
  local cleanup_mode
  cleanup_mode=$(env_get "THREAD_CLEANUP" "archive")

  info "Stopping thread for ${session_name} (${cleanup_mode})..."

  if load_discord_env 2>/dev/null; then
    local thread_id
    thread_id=$(discord_find_thread "$thread_name")
    if [[ -n "$thread_id" ]]; then
      discord_post_to_thread "$thread_id" "Session \`${session_name}\` stopped on \`${hostname_short}\` ¬∑ ${timestamp}"
      if [[ "$cleanup_mode" == "delete" ]]; then
        discord_delete_thread "$thread_id"
        ok "[discord] Thread deleted"
      else
        discord_archive_thread "$thread_id"
        ok "[discord] Thread archived"
      fi
    else
      info "[discord] No thread found"
    fi
  fi

  if load_slack_env 2>/dev/null; then
    local thread_ts
    thread_ts=$(slack_find_thread "$thread_name")
    if [[ -n "$thread_ts" ]]; then
      slack_post_to_thread "$thread_ts" "Session \`${session_name}\` stopped on \`${hostname_short}\` ¬∑ ${timestamp}"
      if [[ "$cleanup_mode" == "delete" ]]; then
        slack_delete_thread "$thread_ts"
        ok "[slack] Thread deleted"
      else
        slack_archive_thread "$thread_ts"
        ok "[slack] Thread archived"
      fi
    else
      info "[slack] No thread found"
    fi
  fi
}

# -------------------------------------------------------------------
# aily auto [on|off]
# -------------------------------------------------------------------
cmd_auto() {
  local action="${1:-}"
  case "$action" in
    on)
      env_set "TMUX_THREAD_SYNC" "true"
      ok "Auto thread sync: ON"
      ;;
    off)
      env_set "TMUX_THREAD_SYNC" "false"
      ok "Auto thread sync: OFF"
      ;;
    "")
      local current
      current=$(env_get "TMUX_THREAD_SYNC" "true")
      if [[ "$current" == "false" ]]; then
        info "Auto thread sync: OFF"
      else
        info "Auto thread sync: ON"
      fi
      ;;
    *)
      echo "Usage: aily auto [on|off]" >&2
      exit 1
      ;;
  esac
}

# -------------------------------------------------------------------
# aily usage
# -------------------------------------------------------------------

cmd_usage() {
  require_deps

  local subcmd="${1:-}"
  shift 2>/dev/null || true

  case "$subcmd" in
    queue)
      _usage_queue "$@"
      return
      ;;
  esac

  # Default: show current usage
  local resp
  resp=$(api_call GET "/api/usage" 2>/dev/null || echo "")

  if [[ -z "$resp" ]]; then
    err "Dashboard unavailable"
    return 1
  fi

  if json_output "$resp"; then return; fi

  hdr "API Usage (Rate Limits)"
  echo ""

  # Parse providers from response
  local providers
  providers=$(echo "$resp" | jq -r '.usage // {} | keys[]' 2>/dev/null)

  if [[ -z "$providers" ]]; then
    info "No usage data available. Enable USAGE_POLLER in dashboard settings."
    echo ""
    return
  fi

  for provider in $providers; do
    # Single jq call to extract all fields at once
    local -a fields
    mapfile -t fields < <(echo "$resp" | jq -r ".usage[\"$provider\"] |
      (.poll_status_code // \"?\"),
      (.polled_at // \"-\"),
      (.requests_remaining // \"?\"),
      (.requests_limit // \"?\"),
      (.input_tokens_remaining // \"?\"),
      (.input_tokens_limit // \"?\"),
      (.output_tokens_remaining // \"?\"),
      (.output_tokens_limit // \"?\"),
      (.tokens_remaining // \"?\"),
      (.tokens_limit // \"?\"),
      (.error_message // empty)")
    local status_code="${fields[0]:-?}"
    local polled_at
    polled_at=$(echo "${fields[1]:--}" | sed 's/T/ /;s/\..*//')
    local req_rem="${fields[2]:-?}" req_lim="${fields[3]:-?}"
    local in_rem="${fields[4]:-?}" in_lim="${fields[5]:-?}"
    local out_rem="${fields[6]:-?}" out_lim="${fields[7]:-?}"
    local tok_rem="${fields[8]:-?}" tok_lim="${fields[9]:-?}"
    local err_msg="${fields[10]:-}"

    printf "  ${C_BOLD}${C_CYAN}%s${C_RESET}  ${C_DIM}(polled: %s, status: %s)${C_RESET}\n" \
      "$provider" "$polled_at" "$status_code"

    printf "    Requests:      %s / %s remaining\n" "$req_rem" "$req_lim"

    if [[ "$in_rem" != "?" && "$in_rem" != "null" ]]; then
      printf "    Input tokens:  %s / %s remaining\n" "$in_rem" "$in_lim"
    fi

    if [[ "$out_rem" != "?" && "$out_rem" != "null" ]]; then
      printf "    Output tokens: %s / %s remaining\n" "$out_rem" "$out_lim"
    fi

    if [[ "$tok_rem" != "?" && "$tok_rem" != "null" ]]; then
      printf "    Tokens:        %s / %s remaining\n" "$tok_rem" "$tok_lim"
    fi

    if [[ -n "$err_msg" ]]; then
      printf "    ${C_RED}Error: %s${C_RESET}\n" "$err_msg"
    fi
    echo ""
  done

  # Queue stats
  local pending
  pending=$(echo "$resp" | jq -r '.queue_stats.pending // 0')
  if [[ "$pending" != "0" ]]; then
    printf "  ${C_YELLOW}Command queue: %s pending${C_RESET}\n" "$pending"
    info "Run: aily usage queue"
    echo ""
  fi
}

_usage_queue() {
  local action="${1:-}"

  case "$action" in
    add)
      # aily usage queue add <session> <command>
      local session="${2:-}"
      local command="${*:3}"
      if [[ -z "$session" || -z "$command" ]]; then
        echo "Usage: aily usage queue add <session-name> <command>" >&2
        return 1
      fi
      local resp
      resp=$(api_call POST "/api/usage/queue" \
        -d "$(jq -n --arg s "$session" --arg c "$command" '{"session_name":$s, "command":$c}')" 2>/dev/null || echo "")
      if [[ -z "$resp" ]]; then
        err "Failed to enqueue command"
        return 1
      fi
      if json_output "$resp"; then return; fi
      ok "Command queued for session '$session'"
      ;;
    execute)
      local resp
      resp=$(api_call POST "/api/usage/queue/execute" 2>/dev/null || echo "")
      if [[ -z "$resp" ]]; then
        err "Failed to execute queue"
        return 1
      fi
      if json_output "$resp"; then return; fi
      local count
      count=$(echo "$resp" | jq -r '.executed // 0')
      ok "Executed $count queued commands"
      ;;
    *)
      # List queue (default)
      local resp
      resp=$(api_call GET "/api/usage/queue?status=pending" 2>/dev/null || echo "")
      if [[ -z "$resp" ]]; then
        err "Dashboard unavailable"
        return 1
      fi
      if json_output "$resp"; then return; fi

      local total
      total=$(echo "$resp" | jq -r '.total // 0')
      hdr "Command Queue (${total} pending)"
      echo ""

      if [[ "$total" == "0" ]]; then
        info "No pending commands"
        echo ""
        return
      fi

      printf "  ${C_BOLD}%-6s %-24s %-12s %s${C_RESET}\n" "ID" "SESSION" "HOST" "COMMAND"
      printf "  %-6s %-24s %-12s %s\n" "------" "------------------------" "------------" "----------------------------"

      echo "$resp" | jq -r '.commands[] | [(.id|tostring), .session_name, .host, .command] | @tsv' 2>/dev/null | \
        while IFS=$'\t' read -r id session host command; do
          printf "  %-6s %-24s %-12s %s\n" "$id" "$session" "$host" "$command"
        done
      echo ""
      ;;
  esac
}

# -------------------------------------------------------------------
# aily deploy
# -------------------------------------------------------------------
cmd_deploy() {
  local host="${1:-}"
  if [[ -z "$host" ]]; then
    err "Usage: aily deploy <host>"
    exit 1
  fi

  require_deps
  load_env

  hdr "aily deploy ‚Üí ${host}"
  echo ""

  # 1. Test SSH
  if ! ui_spin "Testing SSH to ${host}" \
    ssh -o ConnectTimeout=5 -o BatchMode=yes "$host" "echo ok"; then
    err "Cannot reach ${host} via SSH"
    info "Ensure 'ssh ${host}' works with key auth (no password)"
    exit 1
  fi

  # 2. Sync repo to remote ~/aily
  local remote_dir="~/aily"
  if command -v rsync >/dev/null 2>&1; then
    ui_spin "Syncing aily to ${host}:${remote_dir}" \
      rsync -az --exclude '.env' --exclude '__pycache__' --exclude '.git' \
      "${SCRIPT_DIR}/" "${host}:${remote_dir}/"
  else
    ui_spin "Copying aily to ${host}:${remote_dir}" \
      scp -rq "${SCRIPT_DIR}" "${host}:${remote_dir}"
  fi

  # 3. Copy config
  ui_spin "Copying config to ${host}" \
    ssh -o BatchMode=yes "$host" "mkdir -p ~/.config/aily && chmod 700 ~/.config/aily"
  scp -q "${ENV_FILE}" "${host}:~/.config/aily/env"
  ssh -o BatchMode=yes "$host" "chmod 600 ~/.config/aily/env"
  ok "Config copied"

  # 4. Run init on remote
  printf "\n"
  info "Running init on ${host}..."
  ssh -o BatchMode=yes "$host" "cd ${remote_dir} && ./aily init --non-interactive"
  echo ""
  ok "Deployed to ${host}"

  # 5. Auto-add to SSH_HOSTS if not already listed
  local current_hosts
  current_hosts=$(env_get "SSH_HOSTS" "localhost")
  if [[ ",$current_hosts," != *",$host,"* ]]; then
    env_set "SSH_HOSTS" "${current_hosts},${host}"
    ok "Added ${host} to SSH_HOSTS"
  fi

  echo ""
  info "Verify: aily status"
}

# -------------------------------------------------------------------
# aily bridge [start|stop|status|logs]
# -------------------------------------------------------------------
BRIDGE_SESSION="aily-bridge"

cmd_bridge() {
  local action="${1:-status}"

  case "$action" in
    start)
      if tmux has-session -t "$BRIDGE_SESSION" 2>/dev/null; then
        warn "Bridge already running (tmux session: ${BRIDGE_SESSION})"
        info "Use 'aily bridge logs' to view output"
        return 0
      fi
      require_deps
      load_env
      if [[ ! -f "$ENV_FILE" ]]; then
        err "Config not found. Run 'aily init' first."
        return 1
      fi
      local bridge_script="${SCRIPT_DIR}/agent-bridge.py"
      if [[ ! -f "$bridge_script" ]]; then
        err "agent-bridge.py not found at ${bridge_script}"
        return 1
      fi
      # Check aiohttp dependency
      if ! python3 -c "import aiohttp" 2>/dev/null; then
        err "Python package 'aiohttp' not installed"
        info "Install with: pip3 install aiohttp"
        return 1
      fi
      tmux new-session -d -s "$BRIDGE_SESSION" "python3 '${bridge_script}'" 2>/dev/null
      if tmux has-session -t "$BRIDGE_SESSION" 2>/dev/null; then
        ok "Bridge started (tmux session: ${BRIDGE_SESSION})"
        info "Discord commands (!new, !kill, !sessions) are now active"
        info "Use 'aily bridge logs' to view output"
      else
        err "Failed to start bridge"
        return 1
      fi
      ;;
    stop)
      if tmux has-session -t "$BRIDGE_SESSION" 2>/dev/null; then
        tmux kill-session -t "$BRIDGE_SESSION" 2>/dev/null
        ok "Bridge stopped"
      else
        info "Bridge is not running"
      fi
      ;;
    restart)
      cmd_bridge stop
      sleep 1
      cmd_bridge start
      ;;
    logs|log)
      if tmux has-session -t "$BRIDGE_SESSION" 2>/dev/null; then
        tmux capture-pane -t "$BRIDGE_SESSION" -p -S -30
      else
        info "Bridge is not running"
      fi
      ;;
    status|"")
      if tmux has-session -t "$BRIDGE_SESSION" 2>/dev/null; then
        ok "Bridge is running (tmux session: ${BRIDGE_SESSION})"
      else
        info "Bridge is not running"
        info "Start with: aily bridge start"
      fi
      ;;
    *)
      echo "Usage: aily bridge [start|stop|restart|status|logs]" >&2
      return 1
      ;;
  esac
}

# -------------------------------------------------------------------
# aily dashboard [start|stop|status|logs]
# -------------------------------------------------------------------
DASHBOARD_PID_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/aily/dashboard.pid"
DASHBOARD_LOG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/aily/dashboard.log"

_dashboard_is_running() {
  # Check PID file first
  if [[ -f "$DASHBOARD_PID_FILE" ]]; then
    local pid
    pid=$(<"$DASHBOARD_PID_FILE")
    if kill -0 "$pid" 2>/dev/null; then
      return 0
    fi
    rm -f "$DASHBOARD_PID_FILE"
  fi
  return 1
}

cmd_dashboard() {
  local action="${1:-status}"

  case "$action" in
    start)
      if _dashboard_is_running; then
        local pid=$(<"$DASHBOARD_PID_FILE")
        warn "Dashboard already running (pid: ${pid})"
        info "Logs: $DASHBOARD_LOG_FILE"
        return 0
      fi
      load_env
      local dash_url
      dash_url=$(env_get "AILY_DASHBOARD_URL" "")
      if [[ -z "$dash_url" ]]; then
        dash_url="http://localhost:8080"
        env_set "AILY_DASHBOARD_URL" "$dash_url"
        ok "Set AILY_DASHBOARD_URL=$dash_url"
      fi
      local port=8080
      if [[ "$dash_url" =~ :([0-9]+) ]]; then
        port="${BASH_REMATCH[1]}"
      fi
      local dash_dir="${SCRIPT_DIR}"
      if [[ ! -f "${dash_dir}/dashboard/__main__.py" ]]; then
        err "dashboard module not found at ${dash_dir}/dashboard/"
        return 1
      fi
      if ! python3 -c "import aiohttp" 2>/dev/null; then
        err "Python package 'aiohttp' not installed"
        info "Install with: pip3 install aiohttp"
        return 1
      fi
      cd "$dash_dir"
      DASHBOARD_PORT="$port" nohup python3 -m dashboard \
        >>"$DASHBOARD_LOG_FILE" 2>&1 &
      local pid=$!
      echo "$pid" > "$DASHBOARD_PID_FILE"
      disown "$pid"
      # Wait briefly for health check
      local i
      for i in 1 2 3 4 5; do
        if curl -sf --connect-timeout 1 "http://localhost:${port}/healthz" >/dev/null 2>&1; then
          ok "Dashboard started on port ${port} (pid: ${pid})"
          info "URL: http://localhost:${port}"
          info "Logs: $DASHBOARD_LOG_FILE"
          return 0
        fi
        sleep 1
      done
      # Process may still be starting
      if kill -0 "$pid" 2>/dev/null; then
        ok "Dashboard started on port ${port} (pid: ${pid})"
        info "Health check pending ‚Äî check logs: $DASHBOARD_LOG_FILE"
      else
        rm -f "$DASHBOARD_PID_FILE"
        err "Dashboard failed to start"
        info "Check logs: $DASHBOARD_LOG_FILE"
        return 1
      fi
      ;;
    stop)
      if _dashboard_is_running; then
        local pid=$(<"$DASHBOARD_PID_FILE")
        kill "$pid" 2>/dev/null
        rm -f "$DASHBOARD_PID_FILE"
        ok "Dashboard stopped (pid: ${pid})"
      else
        info "Dashboard is not running"
      fi
      ;;
    restart)
      cmd_dashboard stop
      sleep 1
      cmd_dashboard start
      ;;
    logs|log)
      if [[ -f "$DASHBOARD_LOG_FILE" ]]; then
        tail -30 "$DASHBOARD_LOG_FILE"
      else
        info "No log file found"
      fi
      ;;
    status|"")
      load_env
      local dash_url
      dash_url=$(env_get "AILY_DASHBOARD_URL" "")
      if _dashboard_is_running; then
        local pid=$(<"$DASHBOARD_PID_FILE")
        ok "Dashboard is running (pid: ${pid})"
        info "URL: ${dash_url:-http://localhost:8080}"
      elif [[ -n "$dash_url" ]] && curl -sf --connect-timeout 2 "${dash_url}/healthz" >/dev/null 2>&1; then
        ok "Dashboard is reachable"
        info "URL: ${dash_url}"
      else
        info "Dashboard is not running"
        info "Start with: aily dashboard start"
      fi
      ;;
    *)
      echo "Usage: aily dashboard [start|stop|restart|status|logs]" >&2
      return 1
      ;;
  esac
}

# -------------------------------------------------------------------
# aily uninstall
# -------------------------------------------------------------------
cmd_uninstall() {
  hdr "aily uninstall"
  echo ""

  # Confirm
  printf "  This will remove aily hook symlinks and agent configurations.\n"
  printf "  Your credentials file will also be deleted.\n"
  echo ""
  printf "  ${C_BOLD}Continue? (y/N):${C_RESET} "
  local answer
  read -r answer
  case "$answer" in
    [Yy]|[Yy][Ee][Ss]) ;;
    *)
      echo "  Aborted."
      exit 0
      ;;
  esac
  echo ""

  # 1. Remove hook symlinks
  printf "  ${C_BOLD}Removing hook symlinks${C_RESET}\n"
  local hook_files
  hook_files=$(find "$HOOKS_DIR" -maxdepth 1 -type l 2>/dev/null || true)
  if [[ -n "$hook_files" ]]; then
    while IFS= read -r link; do
      local link_target
      link_target=$(readlink "$link" 2>/dev/null || echo "")
      # Only remove symlinks pointing to our hooks directory
      if [[ "$link_target" == *"/hooks/"* ]]; then
        rm -f "$link"
        ok "Removed $(basename "$link")"
      fi
    done <<< "$hook_files"
  else
    info "No hook symlinks found"
  fi

  # 2. Remove from Claude Code settings.json
  printf "\n  ${C_BOLD}Cleaning agent configurations${C_RESET}\n"
  local claude_settings="$HOME/.claude/settings.json"
  if [[ -f "$claude_settings" ]] && grep -q "notify-clawdia\|notify-claude" "$claude_settings" 2>/dev/null; then
    warn "Claude Code: Remove the aily hook from ${claude_settings} manually"
  else
    info "Claude Code: no aily hook found"
  fi

  # Codex config.toml
  local codex_config="$HOME/.codex/config.toml"
  if [[ -f "$codex_config" ]] && grep -q "notify-codex" "$codex_config" 2>/dev/null; then
    # Remove the notify line
    python3 -c "
import re, sys
path = sys.argv[1]
with open(path) as f:
    text = f.read()
text = re.sub(r'^notify\s*=.*notify-codex.*\n?', '', text, flags=re.MULTILINE)
with open(path, 'w') as f:
    f.write(text)
" "$codex_config" 2>/dev/null && ok "Codex CLI: removed notify hook" || warn "Codex CLI: failed to update config"
  else
    info "Codex CLI: no aily hook found"
  fi

  # Gemini settings.json
  local gemini_settings="$HOME/.gemini/settings.json"
  if [[ -f "$gemini_settings" ]] && grep -q "notify-gemini" "$gemini_settings" 2>/dev/null; then
    python3 -c "
import json, sys
path = sys.argv[1]
with open(path) as f:
    settings = json.load(f)
hooks = settings.get('hooks', {})
after_agent = hooks.get('AfterAgent', [])
if isinstance(after_agent, list):
    new_groups = []
    for group in after_agent:
        if isinstance(group, dict):
            group_hooks = group.get('hooks', [])
            group_hooks = [h for h in group_hooks
                          if not (isinstance(h, dict) and
                                  (h.get('name') == 'discord-notify' or
                                   str(h.get('command', '')).endswith('notify-gemini.sh')))]
            if group_hooks:
                group['hooks'] = group_hooks
                new_groups.append(group)
        else:
            new_groups.append(group)
    hooks['AfterAgent'] = new_groups
    settings['hooks'] = hooks
with open(path, 'w') as f:
    json.dump(settings, f, indent=2)
    f.write('\n')
" "$gemini_settings" 2>/dev/null && ok "Gemini CLI: removed notify hook" || warn "Gemini CLI: failed to update config"
  else
    info "Gemini CLI: no aily hook found"
  fi

  # OpenCode plugins
  local opencode_plugins="$HOME/.config/opencode/plugins"
  if [[ -d "$opencode_plugins" ]]; then
    local oc_found=false
    for f in "$opencode_plugins"/aily-notify* "$opencode_plugins"/notify-opencode*; do
      if [[ -e "$f" ]]; then
        rm -f "$f" && ok "OpenCode: removed $(basename "$f")" || warn "OpenCode: failed to remove $(basename "$f")"
        oc_found=true
      fi
    done
    if [[ "$oc_found" == "false" ]]; then
      info "OpenCode: no aily plugin found"
    fi
  else
    info "OpenCode: plugins dir not found"
  fi

  # 3. Stop bridge bot
  printf "\n  ${C_BOLD}Stopping services${C_RESET}\n"
  if tmux has-session -t "$BRIDGE_SESSION" 2>/dev/null; then
    tmux kill-session -t "$BRIDGE_SESSION" 2>/dev/null
    ok "Stopped bridge (tmux: ${BRIDGE_SESSION})"
  else
    info "Bridge not running"
  fi
  if _dashboard_is_running; then
    local pid=$(<"$DASHBOARD_PID_FILE")
    kill "$pid" 2>/dev/null
    rm -f "$DASHBOARD_PID_FILE"
    ok "Stopped dashboard (pid: ${pid})"
  else
    info "Dashboard not running"
  fi

  # 4. Remove tmux hooks
  printf "\n  ${C_BOLD}Removing tmux hooks${C_RESET}\n"
  if command -v tmux >/dev/null 2>&1 && tmux list-sessions >/dev/null 2>&1; then
    tmux set-hook -gu session-created 2>/dev/null && ok "Removed session-created hook" || info "No session-created hook"
    tmux set-hook -gu session-closed 2>/dev/null && ok "Removed session-closed hook" || info "No session-closed hook"
  else
    info "tmux not running"
  fi

  # 4. Remove CLI symlink
  printf "\n  ${C_BOLD}Removing CLI symlink${C_RESET}\n"
  local aily_link="$HOME/.local/bin/aily"
  if [[ -L "$aily_link" ]]; then
    rm -f "$aily_link"
    ok "Removed ${aily_link}"
  else
    info "No CLI symlink found"
  fi

  # 5. Remove credentials file
  printf "\n  ${C_BOLD}Removing credentials${C_RESET}\n"
  if [[ -f "$ENV_FILE" ]]; then
    rm -f "$ENV_FILE"
    ok "Removed ${ENV_FILE}"
  else
    info "No credentials file found"
  fi
  # Clean up config dir if empty
  local config_dir
  config_dir="$(dirname "$ENV_FILE")"
  rmdir "$config_dir" 2>/dev/null && ok "Removed ${config_dir}" || true

  echo ""
  ok "Uninstall complete"
  info "To re-install, run: ./aily init (from the repo directory)"
  echo ""
}

# -------------------------------------------------------------------
# aily help / version
# -------------------------------------------------------------------
cmd_help() {
  echo ""
  box_top "aily"
  box_line "AI agent notification relay  ${C_DIM}v${AILY_VERSION:-dev}${C_RESET}"
  box_bottom
  echo ""
  printf "${C_BOLD}Usage:${C_RESET}\n"
  echo "  aily [--json] [--verbose] <command> [options]"
  echo ""
  printf "${C_BOLD}Setup & diagnostics:${C_RESET}\n"
  echo "  init                      Interactive setup wizard"
  echo "    --non-interactive         Read from env vars instead of prompting"
  echo "  status                    Show configuration and connectivity"
  echo "  doctor                    Diagnose common issues"
  echo "  deploy <host>             Deploy aily to a remote host via SSH"
  echo "  uninstall                 Remove hooks and agent configurations"
  echo ""
  printf "${C_BOLD}Dashboard:${C_RESET}\n"
  echo "  sessions                  List active sessions from dashboard"
  echo "    --json                    Output raw JSON"
  echo "    --ssh                     List via SSH instead of dashboard API"
  echo "  sync [session-name]       Trigger message sync for a session"
  echo "  logs [session-name]       Fetch recent messages for a session"
  echo "  tail [session-name]       Alias for logs"
  echo "  export [session-name]     Export a session to markdown or json"
  echo "    --json                    Output raw JSON"
  echo "    -n, --limit N             Number of messages (default: 20)"
  echo "  attach [session-name]     Attach to an active tmux session"
  echo ""
  printf "${C_BOLD}Configuration:${C_RESET}\n"
  echo "  config show               Show current config (tokens redacted)"
  echo "  config set KEY VALUE      Update a config key"
  echo "  config dashboard-url URL  Shortcut: set dashboard URL"
  echo ""
  printf "${C_BOLD}Usage monitoring:${C_RESET}\n"
  echo "  usage                     Show current API rate limit status"
  echo "    --json                    Output raw JSON"
  echo "  usage queue               Show pending command queue"
  echo "  usage queue add S CMD     Queue a command for session S"
  echo "  usage queue execute       Manually execute all pending commands"
  echo ""
  printf "${C_BOLD}Thread management:${C_RESET}\n"
  echo "  start [name]              Create thread (default: current tmux session)"
  echo "  stop [name]               Archive thread (default: current tmux session)"
  echo "  auto [on|off]             Toggle auto thread sync (or show status)"
  echo ""
  printf "${C_BOLD}Services:${C_RESET}\n"
  echo "  bridge start|stop|restart Start/stop the Discord command bridge"
  echo "  bridge status|logs        Show bridge status or output"
  echo "  dashboard start|stop      Start/stop the web dashboard"
  echo "  dashboard status|logs     Show dashboard status or output"
  echo ""
  printf "${C_BOLD}General:${C_RESET}\n"
  echo "  help, -h, --help          Show this help"
  echo "  version, -v, --version    Show version"
  echo ""
  echo "Config file: ${ENV_FILE}"
  echo "Dashboard:   $(dashboard_url)"
  echo ""
}

cmd_version() {
  printf "aily %s\n" "${AILY_VERSION:-dev}"
}

# ===================================================================
# MAIN
# ===================================================================

# Parse global flags.
while [[ "${1:-}" == --* ]]; do
  case "$1" in
    --json) AILY_JSON=true; shift ;;
    --verbose) set -x; shift ;;
    --help) cmd_help; exit 0 ;;
    *) break ;;
  esac
done

CMD="${1:-help}"
shift 2>/dev/null || true

case "$CMD" in
  init)       cmd_init "$@" ;;
  status)     cmd_status "$@" ;;
  sessions)   cmd_sessions "$@" ;;
  sync)       cmd_sync "$@" ;;
  logs)       cmd_logs "$@" ;;
  tail)       cmd_logs "$@" ;;
  attach)     cmd_attach "$@" ;;
  export)     cmd_export "$@" ;;
  config)     cmd_config "$@" ;;
  doctor)     cmd_doctor "$@" ;;
  start)      cmd_start "$@" ;;
  stop)       cmd_stop "$@" ;;
  auto)       cmd_auto "$@" ;;
  usage)      cmd_usage "$@" ;;
  bridge)     cmd_bridge "$@" ;;
  dashboard)  cmd_dashboard "$@" ;;
  deploy)     cmd_deploy "$@" ;;
  uninstall)  cmd_uninstall "$@" ;;
  help|-h|--help) cmd_help ;;
  version|-v|--version) cmd_version ;;
  *)
    err "Unknown command: ${CMD}"
    echo ""
    cmd_help
    exit 1
    ;;
esac
